{"./":{"url":"./","title":"简介","keywords":"","body":"简介 本文档是平时学习工作中对各类知识的总结。 运行 安装 GitBooknpm install gitbook-cli -g Clone 代码到本地并运行gitbook install gitbook serve 在浏览器中打开 http://localhost:4000/ 进行访问 可以使用gitbook build ./ ./docs命令，生成静态网页，并指定docs为生成目录，而不是默认的_book。 因为我们的Github Pages使用的是docs目录，所以发布需要使用此命令 gitbook使用链接：https://www.jianshu.com/p/421cc442f06c 发布 --测试环境 https://github.com/nov-moon/airbook https://nov-moon.github.io/airbook Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2021-06-02 10:47:30 "},"flutter/第三方框架/":{"url":"flutter/第三方框架/","title":"Flutter-第三方库","keywords":"","body":"第三方库 本文档主要包括常用第三方库的源码阅读与分享 Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2021-05-21 18:08:17 "},"flutter/第三方框架/GetX/":{"url":"flutter/第三方框架/GetX/","title":"GetX","keywords":"","body":"GetX GetX是Flutter中比较流行的框架，主要提供：路由管理、依赖管理、状态管理。 官方地址：https://github.com/jonataslaw/getx/blob/master/README.zh-cn.md Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2021-05-21 18:08:17 "},"flutter/第三方框架/GetX/GetX（一）.html":{"url":"flutter/第三方框架/GetX/GetX（一）.html","title":"从官方demo开始","keywords":"","body":"GetX（一）从demo开始 Flutter是响应式编程架构，在Flutter开发中，经常遇到如何便捷的更新状态和如何方便快捷的传递上下文共享数据。 GetX提供了相应功能。 在GetX的官方demo中，演示了如何便捷高效的更新UI： class HomePage extends StatelessWidget { final model = CountModel(); @override Widget build(BuildContext context) { return Scaffold( // 使用Obx(()=>每当改变计数时，就更新Text()。 appBar: AppBar(title: Obx(() => Text(\"Clicks: ${model.count}\"))), body: Center(), floatingActionButton: FloatingActionButton( child: Icon(Icons.add), onPressed: () => model.count++, )); } } class CountModel { var count = 0.obs; } 在上述代码中，更改了部分官方代码，以便简化代码，突出重点 在上述代码中我们看到，我们使用了一个StatelessWidget，做到了UI更新，非常的神奇。 上面的代码和我们平时动态更新ui的代码有三处不同：CountModel中的0.obs、使用了StatelessWidget、Obx(() => Text(\"Clicks: ${model.count}\"))。 下面我们对新出现的obs和Obx实现进行学习，尝试解开其中神奇的魔力来源。 0.obs中的魔法 看到GetX中0.obs语法，那么他必然是使用了Dart中的扩展语法，源码如下： // rx_impl.dart extension IntExtension on int { /// Returns a `RxInt` with [this] `int` as initial value. RxInt get obs => RxInt(this); } extension StringExtension on String { /// Returns a `RxString` with [this] `String` as initial value. RxString get obs => RxString(this); } extension DoubleExtension on double { /// Returns a `RxDouble` with [this] `double` as initial value. RxDouble get obs => RxDouble(this); } extension BoolExtension on bool { /// Returns a `RxBool` with [this] `bool` as initial value. RxBool get obs => RxBool(this); } extension RxT on T { /// Returns a `Rx` instace with [this] `T` as initial value. Rx get obs => Rx(this); } 从上述源码可知，GetX支持String、Int、Double、Bool、T，所以任意类型都可以使用 .obs 。 以int为例，进一步看一下具体实现。 我们知道，在Dart中一个类可以通过extends、implement、mixin三种方式集成其他类的功能。如果单说继承不足以描述三种实现方式。extends是传统的继承方式，implements是传统的接口实现方式，mixin是Dart中直接集成其他类功能的方式。 当我们调用0.obs时，他的返回类型其实为RxInt。 而RxInt类的继承关系如下图： 其实其他的RxString、RxDouble、RxBool、Rx都是_RxImpl的子类，而其中的间接父类只是提供了对应类型的自有能力，例如RxInt可以支持加减乘除等数字操作，而这些能力来源于间接父类_BaseRxNum和他本身。 所以我们可以猜到，_RxImpl其实是支持魔法的根源。 _RxImpl类分两部分组成，mixin进来的RxObjectMixin和继承进来的RxNotifier。 RxNotifier 首先我们看一下RxObjectMixin，代码如下： // 绑定的数据 T _value; // 刷新，转入了subject方法 void refresh() { subject.add(value); } // 设置空值 void nil() { subject.add(_value = null); } // 提供直接括号的语法糖调用方式 T call([T v]) { if (v != null) { value = v; } return value; } // .... 省略了一些hash == 等方法 // 设置value，如果不是首次build，并且值相同则不更新。 // 将新的value转入subject set value(T val) { if (_value == val && !firstRebuild) return; firstRebuild = false; _value = val; subject.add(_value); } // 当获取value时，查看proxy是否为null，不为null时则使用subject监听proxy T get value { if (RxInterface.proxy != null) { RxInterface.proxy.addListener(subject); } return _value; } 从上面的代码可知，RxObjectMixin提供了数据绑定以及方便的刷新等方法。 而subject不属于RxObjectMixin类，则他必然来自RxNotifier。 这里需要注意的是value的get方法中的RxInterface.proxy，后面我们会再遇到RxInterface.proxy。 RxNotifier 通过上面的分析可知，RxInt数据绑定的能力来自RxObjectMixin，那么他数据监听和更新的能力，必然来自RxNotifier(只有两个父类，所以另一部分能力必然来自它)。 由上图可知，RxNotifier实现了RxInterface接口，而RxNotifier的代码如下： class RxNotifier = RxInterface with NotifyManager; 我们看到，RxNotifier并没有自己的实体，所以接口RxInterface定义的方法，都由NotifyManager实现。 而NotifyManager类确实实现了RxInterface功能定义，大体源码如下： // 低层的监听果然使用的是流 GetStream subject = GetStream(); // 流的订阅者 final _subscriptions = >{}; bool get canUpdate => _subscriptions.isNotEmpty; // 将当前stream的add回调，添加到入参流rxGetx的事件监听中。当rxGetx发生变化时会回调subject.add，并将订阅者添加到_subscriptions中，以便关闭和资源回收。 void addListener(GetStream rxGetx) { if (!_subscriptions.containsKey(rxGetx)) { final subs = rxGetx.listen(subject.add); final listSubscriptions = _subscriptions[rxGetx] ??= []; listSubscriptions.add(subs); } } // 添加事件流更改时的监听 StreamSubscription listen( void Function(T) onData, { Function onError, void Function() onDone, bool cancelOnError = false, }) => subject.listen(onData, onError: onError, onDone: onDone, cancelOnError: cancelOnError); // 关闭订阅者等资源 void close() { .... } 从上述源码中可知，RxNotifier提供了两个东西：真正的流GetStream、将其他GetStream的事件变更转发到当前持有的GetStream。 由此可知GetStream提供了所有的流事件的管理和分发。 GetStream GetStream提供了一系列的监听方法，用于对流的状态监听。提供了一系列的管理方法，用于管理订阅者和事件分发。源码如下： class GetStream { // 当添加新的监听时的回调方法 void Function() onListen; // 当订阅者暂停时的回调 void Function() onPause; // 当订阅者恢复时的回调 void Function() onResume; // 当前流cacenl时的回调 FutureOr Function() onCancel; // 为当前流移除订阅者 FutureOr removeSubscription(LightSubscription subs); // 为当前流添加订阅者 FutureOr addSubscription(LightSubscription subs); // 数据变化时更新所有订阅者 void _notifyData(T data); // 发生错误时，通知所有订阅者 void _notifyError(Object error, [StackTrace stackTrace]); // 流完成时通知订阅者 void _notifyDone(); // 当前流最后一个事件对象 T _value; // 添加事件 void add(T event) { _value = event; // 转发到_notifyDate() _notifyData(event); } // 给当前流添加新的监听 LightSubscription listen(void Function(T event) onData,{Function onError, void Function() onDone, bool cancelOnError}) { final subs = LightSubscription(removeSubscription,onPause: onPause,onResume: onResume,onCancel: onCancel,) ..onData(onData) ..onError(onError) ..onDone(onDone) ..cancelOnError = cancelOnError; addSubscription(subs); onListen?.call(); return subs; } // 将GetStream转化为流的方式返回。 Stream get stream => GetStreamTransformation(addSubscription, removeSubscription); } 在上述源码中，使用到了LightSubscription，他只是对订阅者的简单封装，有兴趣的同学可以自行查看。 至此通过源码发现，所有的可观察类都是_RxImpl的子类，他提供了数据绑定(RxObjectMixin)和数据变化时的事件管理和分发(RxNotifier)的能力。 然而事件分发给谁呢？我们根据counter功能大胆推测一下，数据的变更事件可能都分发给了Obx()，从而促使Obx进行更新，最终UI更新。 Obx(() => Text(\"Clicks: ${model.count}\")) 在Flutter中，如果需要更新UI，在不使用黑魔法的前提下，我们推测GetX内部大概率同样使用了StatefulWidget。 通过源码可知，Obx的继承关系为：Obx -> ObxWidget -> StatefulWidget。 到此可知，Obx的更新确实是基于StatefulWidget。 ObxWidget对应的State为_ObxState，源码如下： class _ObxState extends State { // 当前持有的观察者对象 RxInterface _observer; // 当前的订阅者对象 StreamSubscription subs; _ObxState() { // RxNotifier上文提到过，提供了事件的监听管理和分发 _observer = RxNotifier(); } @override void initState() { // 对观察者添加监听，当_observer内容发生变化时，触发_updateTree subs = _observer.listen(_updateTree); super.initState(); } // 调用setState触发更新 void _updateTree(_) { if (mounted) { setState(() {}); } } // 关闭观察者，取消订阅者 @override void dispose() { subs.cancel(); _observer.close(); super.dispose(); } // 调用widget中的build，更新child。 Widget get notifyChilds { final observer = RxInterface.proxy; RxInterface.proxy = _observer; final result = widget.build(); if (!_observer.canUpdate) { // 抛出错误，省略... } RxInterface.proxy = observer; return result; } @override Widget build(BuildContext context) => notifyChilds; } 通过上面的源码可知，_ObxState基本上都是对_observer的监听等操作的处理。 当_observer发生变化时，更新当前widget。当前widget回收时，关闭_observer并取消订阅者。 然而并没有发现counter更改时，如何触发widget更改。 我们在分析RxObjectMixin的源码时曾经看到其中_value的get方法，有一段如下源码： // 当获取value时，查看proxy是否为null，不为null时则使用subject监听proxy T get value { if (RxInterface.proxy != null) { RxInterface.proxy.addListener(subject); } return _value; } 而_ObxState中的notifyChilds方法为： // 调用widget中的build，更新child。 Widget get notifyChilds { final observer = RxInterface.proxy; RxInterface.proxy = _observer; final result = widget.build(); if (!_observer.canUpdate) { // 抛出错误，省略... } RxInterface.proxy = observer; return result; } 在此方法中，同样有对RxInterface.proxy的操作。他将原来的proxy存入临时变量，并将当前_observer设置为全局proxy，再调用build。完成以后再恢复原始proxy。一顿蜜汁操作。。。 我们看一下在notifyChilds方法的具体调用链路，如下： 如上图所示，在（3）中_ObxState将proxy设置为_observer，而在（6）中Text(\"Clicks: ${model.count}\")，系统会将String拼串操作转换为Text(\"Clicks: ${model.count.toString()}\")，触发了（7）的toString()，而toString()的实现为：value.toString()，使用了value对象，从而触发了value的get方法（8）、（9），在get方法中使用（3）中设置的_observer(_ObxState中的对象)监听当前counter上的事件变更。一系列调用完成后，在（13）中再将proxy恢复成原始proxy。 这也解释了在notifyChilds()方法中替换proxy的蜜汁操作。 当_ObxState回收时，同时回收事件订阅器，以及关闭当前_observer对象。 总结 我们从头再理一下思路。 count通过扩展的方式，获取到了一个支持数据绑定(RxObjectMixin)和数据事件分发(RxNotifier)的Rx对象。 当系统构建UI时，调用_ObxState的build()方法，从而以隐式的方式调用count.toString()方法，而RxObjectMixin.toString()方法又隐式的调用了value的get方法。在get方法中，由于之前的proxy交换操作，致使当前proxy为当前_ObxState._observer，最终将value的数据变更流整合到了_ObxState._observer中。 当count变更时，触发他自己的事件流，同时触发_ObxState._observer的事件流，最终更新UI。 这一步proxy变换和value的get操作，堪称神来之笔，膜拜~ 同时，通过源码可知，在Obx的build回调中不可轻易更改proxy，否则将导致proxy链接到的对象错误，从而导致不能正确分发事件，不能更新UI。 但是在Obx中可同时多层嵌套Obx，因为每次build时都会恢复成之前的proxy。 思考 如果在Rx对象中不使用Stream 其实在Rx对象的实现中并没有直接使用Stream，GetStream也只是借鉴了Stream的事件思想以及分发套路。value值的变更是事件的原动力，每次变更都会对应一次事件的生成。同时又需要将事件分发给所有的订阅者们，以便订阅者更新自己。这个套路就是Stream的广播订阅模式。 为什么不使用Stream 虽然GetStream叫Stream，但是他并不是Stream的子类。作为Flutter中的基础框架类，Stream提供的能力更加庞杂，更加多变。然而GetStream并不需要这么庞杂的能力，只需要聚焦到事件管理和分发就可以了。 如果有更多的更新元素 我们通过源码分析可以知道，每个可更新元素都对应两个NotifyManager，两个GetStream，每多增加一个Obx都会增加一套相应的对象用来完成订阅。而每套对象中又包含相应的配套对象。虽然多次调用setState并不会触发帧的更新，但是仍然会有很多对象生成，以及很多关联调用。例如在列表更新中，GetX提供了GetBuilder和GetX用于批量更新。那让我们看一下他是如何提高效率的。 Get.put(instance)分析 GetxController GetxController类提供了两个功能：生命周期管理、广播内容变化 对于生命周期管理，它继承了GetLifeCycleBase类，提供了：onInit()、onReady()、onClose()。 onInit()回调方法在当前controller被加载到内存中后，第一时间调用。 onReady()方法在下一帧刷新时调用，一般用来处理dialog之类需要下一帧时机 onClose()方法用来处理一些资源回收。 对于广播内容变化功能，GetxController提供了update()方法，用于更新订阅者。 put()方法实现 通过调用put()方法，将实例添加到了GetX中名为_singl的静态map中，再直接通过find()方法返回传入实例。 find()方法，会从_singl中查找，并检查是否已经初始化。 如果未初始化，则直接调用传入的build方法(如果没有传入build则默认生成一个build方法，返回传入的实例)，获取实例。 获取完成实例以后，会检查当前实例是否为GetLifeCycleBase类型，我们前面分析GetxController类时已经说明，他通过继承GetLifeCycleBase，提供了生命周期方法。 如果当前实例为GetLifeCycleBase类型，则调用其onStart()回调方法 尝试将当前route引用加入到route列表中 Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2021-05-21 18:08:17 "},"flutter/第三方框架/GetX/GetX（二）.html":{"url":"flutter/第三方框架/GetX/GetX（二）.html","title":"GetxController和GetX","keywords":"","body":"GetX（二）GetxController和GetX 在上文中的官方demo部分，我们贴出的源码是简单改动过的。 而改动的部分主要是将CountModel由GetxController的子类，更换为了普通对象。 下面我们一块学习一下GetxController源码。 1. GetxController的实现 先不说其他，先看一下GetxController的继承结构，如下图： 由上图可知，GetxController通过继承DisposableInterface和mixin ListNotifier的方式，提供了生命周期和批量更新的能力。 DisposableInterface DisposableInterface通过继承GetLifeCycle，提供了如下生命周期方法： onStart 虽然是Function类型，但是以final变量的方式存在，用来防止子类重写。本方法将在widget被加载到内存中时由框架调用。此方法的默认实现会检查是否已经初始化，如果没有，则调用onInit()方法，所以多次调用onStart，只会执行一次onInit() onInit() 本方法会在widget被加载到内存中后调用。一般用来初始化一些后续需要使用的对象。 onReady() 此方法会比onInit()方法晚调用一帧，此方法一般用于执行snackbar、新的路由等需要页面init完成后执行的操作。 onDelete 和onStart很类似，也是用于框架调用的final变量类型的Function。默认会关联调用onClose()，并且执行多次，也只会执行一次onClose()。 onClose() 此方法用于回收资源，类似Widget中的dispose方法。 对于onReady()方法的描述，我们知道他会在onInit()的下一帧调用，我们看一下源码的实现方式： @override @mustCallSuper void onInit() { super.onInit(); SchedulerBinding.instance?.addPostFrameCallback((_) => onReady()); } 我们看到要达到这个效果，这里使用的是SchedulerBinding.instance?.addPostFrameCallback的方式，类似的还有addPersistentFrameCallback方法，有兴趣的童鞋可以了解一下Flutter的加载流程。 ListNotifier 既然是一起看源码，那先上酸菜： class ListNotifier implements Listenable { // 忽略了部分不重要的代码 List _updaters = []; HashMap> _updatersGroupIds = HashMap>(); @protected void refresh() { if (_microtask == _version) { _microtask++; // 异步更新 scheduleMicrotask(() { _version++; _microtask = _version; _notifyUpdate(); }); } } // 简单的更新逻辑 void _notifyUpdate() { for (var element in _updaters) { element(); } } // 按照组id进行更新 void _notifyIdUpdate(Object id) { if (_updatersGroupIds.containsKey(id)) { final listGroup = _updatersGroupIds[id]; for (var item in listGroup) { item(); } } } @protected void refreshGroup(Object id) { // 异步更新 if (_microtask == _version) { _microtask++; scheduleMicrotask(() { _version++; _microtask = _version; _notifyIdUpdate(id); }); } } // 在更新队列_updaters中添加setState方法 @protected void notifyChildrens() { TaskManager.instance.notify(_updaters); } // 删除了部分增加、删除监听的方法 } 由上面的源码可知，ListNotifier提供了两种注册方式：以单个的方式注册更新、以组的方式注册更新。 我们知道Flutter是单线程运行的，在Flutter启动过程中会维护两个队列：EventQueue和MicroTaskQueue。 每次ticker触发时，都会执行两个队列，其中MicroTaskQueue的优先级要高于EventQueue。只有当task执行完成以后，才会执行EventQueue中的内容。 这里使用scheduleMicrotask()方法执行具体的更新操作，可以不阻塞调用方，将具体更新放到下次ticker执行，并且在下次绘制之前得到执行。 2. GetX的自动更新 GetX的官方demo中是这样介绍GetX的： // controller final count1 = 0.obs; final count2 = 0.obs; int get sum => count1.value + count2.value; // 视图 GetX( builder: (controller) { print(\"count 1 rebuild\"); return Text('${controller.count1.value}'); }, ), GetX( builder: (controller) { print(\"count 2 rebuild\"); return Text('${controller.count2.value}'); }, ), GetX( builder: (controller) { print(\"count 3 rebuild\"); return Text('${controller.sum}'); }, ), 如果我们把count1.value++递增，就会打印出来： count 1 rebuild count 3 rebuild 如果我们改变count2.value++，就会打印出来。 count 2 rebuild count 3 rebuild 因为count2.value改变了，sum的结果现在是2。 从Demo看，可能会有三个问题： GetX是如何做到自动更新的？ Controller和GetX是如何交互的？ sum没有使用Rx，但是count1、count2更新时，他同样触发了更新，是如何做到的？ 在看源码的过程中，带着这三个问题，我们一步步寻找答案。 2.1. GetX的自动更新 我们前一篇已经分析过Obx是如何自动更新的，我们已经了解到Obx是如何巧妙的使用全局proxy替换，以及如何巧妙的使用Rx对象的get方法。 我们推测GetX也是基于StatefulWidget的能力进行的UI重绘，也是使用了相同的套路进行事件流监听。 GetX的源码如下： class GetX extends StatefulWidget { final GetXControllerBuilder builder; final bool global; final bool autoRemove; final bool assignId; final void Function(State state) initState, dispose, didChangeDependencies; final void Function(GetX oldWidget, State state) didUpdateWidget; final T init; final String tag; const GetX({ this.tag, this.builder, this.global = true, this.autoRemove = true, this.initState, this.assignId = false, this.dispose, this.didChangeDependencies, this.didUpdateWidget, this.init, }); @override GetXState createState() => GetXState(); } 从上述源码可见： GetX确实是使用的StatefulWidget进行的UI更新 GetX的入参泛型T是DisposableInterface的子类，而DisposableInterface我们前面已经分析过，他主要提供声明周期的功能。所以T类型时具有声明周期的类型，可以是GetXController类型。 GetX提供了一些类似State中的回调方法，用于将State回调时机给到使用方。 GetX还提供了诸如global、tag等入参，我们通过对State的分析，再看具体作用。 从上述源码可以看到GetX是StatefulWidget，对应GetXState类，我们再详细看一下其中的源码： class GetXState extends State> { GetXState() { _observer = RxNotifier(); } RxInterface _observer; // 省略部分代码 Widget get notifyChildren { final observer = RxInterface.proxy; RxInterface.proxy = _observer; final result = widget.builder(controller); if (!_observer.canUpdate) { throw \"错误提示\"; } RxInterface.proxy = observer; return result; } @override Widget build(BuildContext context) => notifyChildren; } 从上述源码可知，和我们推测的一致，GetX也使用了proxy的交换技巧，用以远端设置观察者。 2.2. GetX和GetxController的交互 除了上述源码，State中还有一部分源码，用于和Controller进行交互，如下： // GetXState源码 T controller; bool isCreator = false; StreamSubscription subs; @override void initState() { // 1 var isRegistered = GetInstance().isRegistered(tag: widget.tag); // 2 if (widget.global) { if (isRegistered) { if (GetInstance().isPrepared(tag: widget.tag)) { isCreator = true; } else { isCreator = false; } controller = GetInstance().find(tag: widget.tag); } else { controller = widget.init; isCreator = true; GetInstance().put(controller, tag: widget.tag); } } else { // 3 controller = widget.init; isCreator = true; controller?.onStart(); } // 4 widget.initState?.call(this); if (widget.global && Get.smartManagement == SmartManagement.onlyBuilder) { controller?.onStart(); } // 5 subs = _observer.listen((data) => setState(() {})); super.initState(); } 上述代码的作用如下： GetInstance类提供了跨页面的实例共享与管理。我们暂且不讨论。isRegistered()方法用于判断指定类型下的指定tag对象是否已经在框架中注册。 controller对象如果是全局对象(global=true)，则再检查对象是否已准备就绪。在GetInstance中，如果一个对象已经被init或者对象没有被注册，isPrepared()都会返回false，所以这里先使用isRegistered()确保对象已经被注册，然后使用isPrepared()判断对象是否已经被加载。 如果被加载，则标记controller的创建者为当前state，也就是isCreator=true。 则使用widget.init初始对象，注册到Get中，并设置isCreator=true 如果controller对象是局部对象(global=false)，并且直接将widget.init设置为controller，并调用他的onStart()方法，开启生命周期。 我们在分析GetXController的时候知道，onStart()会调用onInit()方法，所以Controller.onInit()对应State.onInit()。而onReady()方法会在下一帧调用，也就是会在onInit()之后调用。 Get.smartManagement是对GetX中共享对象的管理策略，我们暂时不讨论。 设置当observer的数据流发生变化时，调用setState。和Obx中相似，但是Obx判断了当前State的状态，感觉Obx中的处理会更安全。 其实GetX控件中还有部分代码没有贴出来，基本上都是转发didChangeDependencies()之类的，以及dispose的时候，根据isCreator，是否移除controller对象。 看完GetState的源码以后，我们回过头再仔细看一下GetX的定义： class GetX extends StatefulWidget { final GetXControllerBuilder builder; final bool global; final bool autoRemove; final bool assignId; final void Function(State state) initState, dispose, didChangeDependencies; final void Function(GetX oldWidget, State state) didUpdateWidget; final T init; final String tag; const GetX({ this.tag, this.builder, this.global = true, this.autoRemove = true, this.initState, this.assignId = false, this.dispose, this.didChangeDependencies, this.didUpdateWidget, this.init, }); } tag 我们从State的源码知道，这个tag定义的是从Get中获取共享变量时的key值。所以如果前后两个页面共享相同实例，当tag有自定义的时候，则前后必须一致。 builder 构建真正的显示Widget. global 定义controller变量是否为全局的。 如果不是全局，则会使用init作为controller，跟随当前Widget的生命周期而回收。 如果是全局，则会查找Get中是否有共享实例。 如果没有，使用init参数作为默认controller，并添加到Get中管理。关于是否回收，需要有autoRemove参数决定。 如果有，则复用共享实例。 autoRemove 如果判断出当前实例是由当前widget所create，则会判断此变量，从而在State.dispose()的时候回收共享实例。 initState、dispose、didChangeDependencies、didUpdateWidget 方法会在State相应方法被调用时，进行回调。 assignId 如果此变量为true，则Get中的实例controller，不论是不是当前create的，都会根据autoRemove尝试回收。 init 默认controller对象。 如果global=false，则直接使用此入参为controller。并在dispose的时候根据autoRemove进行删除 如果global=true，则会尝试从Get中加载指定tag以及类型的共享实例，如果没有，则使用init作为默认参数。同样，在dispose的时候根据 是否为当前create或者是否是assignId，以及 是否autoRemove 进行删除 通过源码阅读我们知道GetX是响应式的自动更新，可以设置controller共享对象，并支持controller的自动回收。但是因为这里的controller对象不是真正的GetXController，所以不支持controller内部的update。 GetX和Obx他们都是响应式自动更新，但是两者最大的区别在于GetX支持很多State生命周期的回调，以及controller的实例共享和生命周期触发。 可以认为Obx是轻量级的GetX实现。 2.3. sum是如何更新的 我们再回过头来看之前提到的官方demo中sum的问题：sum没有使用Rx，但是count1、count2更新时，他同样触发了更新，是如何做到的？ 我们通过分析GetX的代码知道，GetX使用了和Obx相同的proxy互换的技巧提供响应式更新。 其实在build第三个GetX的时候使用了sum，sum就会同步使用count1和count2，当调用他们的get方法时，此时的proxy是当前GetX中的observer，所以count1和count2都会再设置GetX中的observer到流监听中。此时count1被GetX1和GetX3监听，count2被GetX2和GetX3监听，所以当他们任意一个改变时都会触发GetX3的更新。 3. 总结 GetxController通过继承DisposableInterface和mixin ListNotifier的方式，提供了生命周期和批量更新的能力。 而GetX要求入参为DisposableInterface类型，实现了共享实例生命周期的维护。与Obx相同，使用了proxy交换的方式，实现了响应式更新。 我们这里的GetxController中的更新能力在GetX中没有使用(入参是DisposableInterface类型)，但是在后面的GetBuilder中将发挥作用。 Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2021-05-21 18:08:17 "},"flutter/第三方框架/GetX/GetX（三）.html":{"url":"flutter/第三方框架/GetX/GetX（三）.html","title":"GetBuilder","keywords":"","body":"GetX(三) GetBuilder 往期列表： Obx中的魔法 GetX中的GetxController和GetX控件 在上一节中我们一块学习了GetX中的GetxController的源码和作用，以及GetX的详细解读。 在本文中，我们继续学习官方demo中的另一个批量更新控件：GetBuilder，代码如下： class GetBuilder extends StatefulWidget { final GetControllerBuilder builder; final bool global; final Object id; final String tag; final bool autoRemove; final bool assignId; final Object Function(T value) filter; final void Function(State state) initState, dispose, didChangeDependencies; final void Function(GetBuilder oldWidget, State state) didUpdateWidget; final T init; const GetBuilder({ Key key, this.init, this.global = true, @required this.builder, this.autoRemove = true, this.assignId = false, this.initState, this.filter, this.tag, this.dispose, this.id, this.didChangeDependencies, this.didUpdateWidget, }) : assert(builder != null), super(key: key); @override _GetBuilderState createState() => _GetBuilderState(); } 从上述源码可以看出，GetBuilder的定义和GetX的定义十分相近，每个参数所提供的功能也基本相同。他们的不同之处在于： 定义规定的泛型不同 class GetBuilder 我们知道GetX规定的入参泛型为 DisposableInterface 类型，所以GetX的入参只支持生命周期回调，而不支持controller手动更新。我们在分析GetxController的源码时介绍过，他继承自DisposableInterface，并且又通过mixin的方式融入了批量更新的功能。所以我们推测GetBuilder支持controller中手动更新。 filter参数 id参数 下面我们具体看一下State的实现，寻找三处不同的具体差别。 1. _GetBuilderState源码分析 我们直接进入正题，查看一下_GetBuilderState的源码： class _GetBuilderState extends State> with GetStateUpdaterMixin { T controller; bool isCreator = false; VoidCallback remove; Object _filter; @override void initState() { super.initState(); // 初始化controller，与GetX中的一致，省略... // 1 if (widget.filter != null) { _filter = widget.filter(controller); } _subscribeToController(); } // 2 void _subscribeToController() { remove?.call(); remove = (widget.id == null) ? controller?.addListener( _filter != null ? _filterUpdate : getUpdate, ) : controller?.addListenerId( widget.id, _filter != null ? _filterUpdate : getUpdate, ); } // 3 void _filterUpdate() { var newFilter = widget.filter(controller); if (newFilter != _filter) { _filter = newFilter; getUpdate(); } } @override Widget build(BuildContext context) { return widget.builder(controller); } } mixin GetStateUpdaterMixin on State { void getUpdate() { if (mounted) setState(() {}); } } 从源码我们看到，GetBuilder中的区别从上到下依次为： mixin GetStateUpdaterMixin 从GetStateUpdaterMixin中的代码我们知道，其实并没有做太多事情，只是增加了state状态判断以及简化了state的调用。 listener的注册 当init执行完成后，会根据当前widget.id是否为null，在controller中注册更新监听。而监听的回调会根据filter的状态，决定是否更新UI。例如，我们的controller是多个GetBuilder共享，当controller更新时，可使用refreshGroup()的方式批量更新对应id的GetBuilder，使用refresh()的方式更新没有指定id的GetBuilder。 filter 根据注释1我们知道，当init的时候会第一次调用filter。 如果返回值不为空，则后续的更新回调，将使用_filterUpdate()的方式进行。而此方法中，又会回调filter，让外部决定是否更新。如果新返回的值与原始值相同，则不更新，否则更新。 如果返回值为空，则直接使用mixin进来的getUpdate方法进行更新 build方法 从源码可以看到，这里并没有像GetX与Obx中那样使用proxy交换的方式远程注册监听，而是直接调用的widget.builder(controller)。由此代码以及listener代码我们可知，GetBuilder不支持自动更新UI，需要配合controller中的refresh、refreshGroup进行UI更新。 2. 总结 通过上面的源码阅读与分析我们知道，GetBuilder的设计是用来与GetxController进行配合使用。在需要批量更新和区别更新(refreshGroup)时，会比GetX和Obx更加灵活。 GetBuilder与GetX等不同，他不支持自动更新。需要我们在Controller中有数据变化和更新需求时，手动的进行更新。 GetBuilder提供了filter参数，通过此参数，我们可以更加细粒度的控制每次更新触发时，是否真正的执行更新，或者过滤掉更新请求。 Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2021-05-21 18:08:17 "},"flutter/Flutter源码/":{"url":"flutter/Flutter源码/","title":"Flutter源码","keywords":"","body":"Flutter框架源码 本文档主要包括Flutter框架源码阅读分享 Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2021-05-27 16:27:18 "},"flutter/Flutter源码/image.html":{"url":"flutter/Flutter源码/image.html","title":"Image源码分析","keywords":"","body":"Image的基本使用 Image是显示图片的一个Widget。image支持的图片格式为：JPEG, PNG, GIF, Animated GIF, WebP, Animated WebP, BMP, and WBMP。 image的基本使用方法: 构造方法 描述 Image() 从ImageProvider中获取图片，从本质上看，下面的几个方法都是他的具体实现。 Image.asset(String name) 从AssetBundler中获取图片 Image.network(String url) 显示网络图片，参数为url Image.file(File file) 从File中获取图片 Image.memory(Uint8List bytes) 从Uint8List中显示图片 具体使用： image.asset加载资源图片 Flutter可以为当前设备加载适合其分辨率的图像。 首先要在根目录assets下,新建image文件夹，由于Flutter加载图片时需要2倍图、3倍图，默认图。所以需要同时新建2.0x和3.0x文件夹。 然后，在pubspec.yaml配置文件中，yaml是类似于xml的一种标记性语言，其中“-”表示数组。在这里，我们也可以使用下面的写法，加载整个资源文件图片： 使用资源图片文件(填入图片的全路径即可)： Image.asset(\"assets/images/flutter.jpeg\") Image.network加载网络图片 Image.network( 'https://image1.guazistatic.com/qn210519171455ac369db6cfecbf11d017210f2986a031.jpg') Image.file加载图片文件 Image.file(File(\"/sdcard/flutter.jpeg\")) 注意在AndroidManifest.xml中配置读写文件权限 Image.memory加载缓存文件 Image.memory(bytes); fit属性的设置 fit属性可以控制图片的拉伸和挤压，这些都是根据图片的父级容器来的. BoxFit.fill:全图显示，图片会被拉伸，并充满父容器。 BoxFit.contain:全图显示，显示原比例，可能会有空隙。 BoxFit.cover：显示可能拉伸，可能裁切，充满（图片要充满整个容器，还不变形）。 BoxFit.fitWidth：宽度充满（横向充满），显示可能拉伸，可能裁切。 BoxFit.fitHeight ：高度充满（竖向充满）,显示可能拉伸，可能裁切。 BoxFit.scaleDown：效果和contain差不多，但是此属性不允许显示超过源图片大小，可小不可大。 repeat图片重复 ImageRepeat.repeat : 横向和纵向都进行重复，直到铺满整个画布。 ImageRepeat.repeatX: 横向重复，纵向不重复。 ImageRepeat.repeatY：纵向重复，横向不重复。 ImageRepeat.noRepeat:不重复。 alignment图片对齐 Alignment.center:居中 Alignment.centerLeft:居左 Alignment.centerRight:居右 Alignment.topCenter:顶部居中 Alignment.topLeft:顶部居左 Alignment.topRight:顶部居右 Alignment.bottomCenter:底部居中 Alignment.bottomLeft:底部居左 Alignment.bottomRight:底部居右 colorBlendMode图片颜色及混合模式 color为源图像，image为目标图像 BlendMode.clear:不显示源图像和目标图像。 BlendMode.src:仅显示源图像。 BlendMode.dst:仅绘制目标图像。 BlendMode.srcOver:源图显示到目标图像上，源图像在上面,透明区域显示目标图层。 BlendMode.dstOver:目标图像显示在源图像上，目标图像在上面。 BlendMode.srcIn: 显示源图像且仅显示两个图像重叠位置。目标图像不绘制，只有不透明度起作用。 BlendMode.dstIn:显示目标图像且仅显示两个图像重叠部分，源图像不绘制只有不透明度起作用。 BlendMode.srcOut:显示源图像且仅显示两个图像不重叠位置。目标图像不绘制，只有不透明度起作用。 BlendMode.dstOut:显示目标图像且仅显示两个图像不重叠部分，源图像不绘制只有不透明度起作用。 BlendMode.srcATop:将源图像合成到目标图像上，但仅在与目标图像重叠的位置合成。但是输出的不透明度通道设置为目标图像的不透明度通道，而不是两个图像的不透明度通道的组合。 BlendMode.dstATop:将目标图像合成到源图像上，但仅在与源图像重叠的位置合成。但是将输出的不透明度通道设置为源图像的不透明度通道，而不是将两个图像的不透明度通道组合在一起。 BlendMode.xor:对源图像和目标图像应用按位“ xor”运算符。这将使它们重叠的地方保持透明。 BlendMode.plus:对源图像和目标图像的组成部分求和。 BlendMode.modulate:将源图像和目标图像的颜色分量相乘。这只能产生相同或较深的颜色（乘以白色1.0，结果不变；乘以黑色0.0，结果黑色）。合成两个不透明图像时，这与在投影机上重叠两个透明胶片具有相似的效果。 BlendMode.screen:将源图像和目标图像的分量的逆值相乘，然后将结果相逆。反转分量意味着将完全饱和的通道（不透明的白色）视为值0.0，将通常视为0.0的值（黑色，透明）视为1.0。这本质上与[调制]混合模式相同，但是颜色的值在乘法之前先反转，结果在渲染前先反转。这只能导致颜色相同或更浅（乘以黑色1.0不会导致更改；乘以白色0.0则会导致白色）。同样，在Alpha通道中，它只能导致更不透明的颜色。这与两台投影机在同一屏幕上同时显示其图像的效果相似。 BlendMode.overlay:在将源图像和目标图像的分量调整为适合目标后，将它们相乘。具体而言，如果目标值较小，则将其与源值相乘，而当源值较小时，则将源值的逆与目标值的逆相乘，然后求反。反转分量意味着将完全饱和的通道（不透明的白色）视为值0.0，将通常视为0.0的值（黑色，透明）视为1.0。 BlendMode.darken:通过从每个颜色通道中选择最小值来合成源图像和目标图像,透明区域显示目标图层。 BlendMode.lighten:通过从每个颜色通道中选择最大值来合成源图像和目标图像,透明区域显示目标图层。 BlendMode.colorDodge:将目标除以源的倒数。反转分量意味着将完全饱和的通道（不透明的白色）视为值0.0，将通常视为0.0的值（黑色，透明）视为1.0。 BlendMode.colorBurn:将目标的倒数除以源，然后将结果倒数。反转分量意味着将完全饱和的通道（不透明的白色）视为值0.0，将通常视为0.0的值（黑色，透明）视为1.0。 BlednMode.hardLight:调整源图像和目标图像的分量以使其适合源图像后，将它们相乘。具体来说，如果源值较小，则将其与目标值相乘，而当目标值较小时，则将目标值的逆与源值的逆相乘，然后求反。反转分量意味着将完全饱和的通道（不透明的白色）视为值0.0，将通常视为0.0的值（黑色，透明）视为1.0 BlendMode.softLight: 对于低于0.5的源值使用[colorDodge]，对于高于0.5的源值使用[colorBurn]。与[overlay]相比，这会产生相似但较柔和的效果 BlendMode.difference: 从每个通道的较大值中减去较小的值。合成黑色没有效果。合成白色会使另一张图像的颜色反转。输出图像的不透明度的计算方法与[srcOver]相同。 BlendMode.exclusion: 从两个图像的总和中减去两个图像的乘积的两倍。合成黑色没有效果。合成白色会使另一张图像的颜色反转。输出图像的不透明度的计算方法与[srcOver]相同。效果类似于[difference]，但较柔和。 BlendMode.multiply: 将源图像和目标图像的分量相乘，包括alpha通道。这只能产生相同或较深的颜色（乘以白色1.0，结果不变；乘以黑色0.0，结果黑色）。由于alpha通道也被相乘，因此一幅图像中的全透明像素（不透明度0.0）导致输出中的全透明像素。这类似于[dstIn]，但将颜色组合在一起。对于多种颜色但不乘以Alpha通道的变体，请考虑[modulate]。 BlendMode.hue: 获取源图像的​​色相，以及目标图像的饱和度和光度。效果是用源图像对目标图像进行着色。输出图像的不透明度的计算方法与[srcOver]相同。源图像中完全透明的区域会从目标获得其相色。 BlendMode.saturation: 获取源图像的​​饱和度以及目标图像的色相和亮度。输出图像的不透明度的计算方法与[srcOver]相同。源图像中完全透明的区域从目标位置开始饱和。 BlendMode.color: 获取源图像的​​色相和饱和度以及目标图像的光度。效果是用源图像对目标图像进行着色。输出图像的不透明度的计算方法与[srcOver]相同。源图像中完全透明的区域从目标位置获得其色相和饱和度。 BlendMode.luminosity: 获取源图像的​​亮度，以及目标图像的色相和饱和度。输出图像的不透明度的计算方法与[srcOver]相同。源图像中完全透明的区域从目的地获取其亮度。 centerSlice图片局部放大： 原图： 效果图： Image的源码 具体图片加载时序图 下面通过Image.network的源码来看下图片是如何下载以及如何缓存的 Image.network( String src, { ...}) : image = ResizeImage.resizeIfNeeded(cacheWidth, cacheHeight, NetworkImage(src, scale: scale, headers: headers)), NetworkImage他的实现类如下： @immutable class NetworkImage extends image_provider.ImageProvider implements image_provider.NetworkImage 可以看到网络加载的图片和AssetImage等都是image_provide的实现类， 它的主要职责有两个： 提供图片数据源 缓存图片 主要基类： resolve方法 @nonVirtual ImageStream resolve(ImageConfiguration configuration) 使用给定的“ configuration”解析此图像，并返回[ImageStream]。这是[ImageProvider]类层次结构的公共入口点。子类应实现此方法使用的[obtainKey]和[load]。如果他们需要更改使用的[ImageStream]的实现，则应重写[createStream]。如果他们需要管理图像的实际分辨率，则应重写[resolveStreamForKey]。 ImageConfiguration 包含图片和设备的相关信息，如图片的大小、所在的AssetBundle(只有打到安装包的图片存在)以及当前的设备平台、devicePixelRatio（设备像素比等）。Flutter SDK提供了一个便捷函数createLocalImageConfiguration来创建ImageConfiguration 对象： @immutable class ImageConfiguration { const ImageConfiguration({ this.bundle, this.devicePixelRatio, this.locale, this.textDirection, this.size, this.platform, }); 具体看下resolve方法 ImageStream resolve(ImageConfiguration configuration) { ... _createErrorHandlerAndKey( configuration, (T key, ImageErrorListener errorHandler) { resolveStreamForKey(configuration, stream, key, errorHandler); }, } 对应resolveStreamForKey方法实现： @protected void resolveStreamForKey(ImageConfiguration configuration, ImageStream stream, T key, ImageErrorListener handleError) { if (stream.completer != null) { final ImageStreamCompleter? completer = PaintingBinding.instance!.imageCache!.putIfAbsent( key, () => stream.completer!, onError: handleError, ); assert(identical(completer, stream.completer)); return; } final ImageStreamCompleter? completer = PaintingBinding.instance!.imageCache!.putIfAbsent( key, () => load(key, PaintingBinding.instance!.instantiateImageCodec), onError: handleError, ); if (completer != null) { stream.setCompleter(completer); } } 有缓存则使用缓存，没有缓存则调用load方法加载图片，加载成功后: 先判断图片数据有没有缓存，如果有，则直接返回ImageStream。 如果没有缓存，则调用load(T key)方法从数据源加载图片数据，加载成功后先缓存，然后返回ImageStream。 这里的PaintingBinding.instance.imageCache 是 ImageCache的一个实例，它是PaintingBinding的一个属性，而Flutter框架中的PaintingBinding.instance是一个单例，imageCache事实上也是一个单例，也就是说图片缓存是全局的，统一由PaintingBinding.instance.imageCache 来管理。 来看一下ImageCache const int _kDefaultSize = 1000; const int _kDefaultSizeBytes = 100 _pendingImages = {};//正在加载中的图片队列 final Map _cache = {};//缓存队列 final Map _liveImages = {};//活动的图片队列 int get maximumSize => _maximumSize; int _maximumSize = _kDefaultSize; 可以看到： _pendingImages正在加载中的图片队列 _cache缓存队列 缓存图片上线1000张，最大缓存100M ImageStreamCompleter? putIfAbsent(Object key, ImageStreamCompleter loader(), { ImageErrorListener? onError }) { ImageStreamCompleter? result = _pendingImages[key]?.completer; // 如果正在加载队列不为空，还没有加载完成，直接返回 if (result != null) { return result; } // 先删除旧的引用，以便后面重新加到最近使用的位置 final _CachedImage? image = _cache.remove(key); if (image != null) { _cache[key] = image; return image.completer; } //如果活动图片不为空，返回活动图片 final _LiveImage? liveImage = _liveImages[key]; if (liveImage != null) { return liveImage.completer; } //以上都没有则调用load加载 try { result = loader(); } catch (error, stackTrace) { if(onError != null) { onError(error, stackTrace); return null; } else { rethrow; } } // 这里设置监听器为false bool listenedOnce = false; // 如果图片缓存不可用，也不应该使用正在加载的图片队列，那么我们至少要有一个监听器监听图片，否则活动图片会有内存泄漏风险 _PendingImage? untrackedPendingImage; void listener(ImageInfo? info, bool syncCall) { int? sizeBytes; if (info != null) { sizeBytes = info.image.height * info.image.width * 4; info.dispose(); } final _CachedImage image = _CachedImage( result!, sizeBytes: sizeBytes, ); //追踪活动图片 _trackLiveImage(key, result, sizeBytes); // 如果初次调用resolve时缓存了那么只追踪图片 if (untrackedPendingImage == null) { _touch(key, image, listenerTask); } else { image.dispose(); } //如果没有加载完成则移除监听 final _PendingImage? pendingImage = untrackedPendingImage ?? _pendingImages.remove(key); if (pendingImage != null) { pendingImage.removeListener(); } //监听状态置为true listenedOnce = true; } //给图片添加监听 final ImageStreamListener streamListener = ImageStreamListener(listener); if (maximumSize > 0 && maximumSizeBytes > 0) { _pendingImages[key] = _PendingImage(result, streamListener); } else { untrackedPendingImage = _PendingImage(result, streamListener); } // 添加监听器 result.addListener(streamListener); return result; } 可以看到，这里检测缓存图片是否存在，存在则直接返回，不存在则删掉缓存中对应的key，然后缓存图片。 //下面检测缓存方法 void _checkCacheSize(TimelineTask? timelineTask) { final Map finishArgs = {}; TimelineTask? checkCacheTask; while (_currentSizeBytes > _maximumSizeBytes || _cache.length > _maximumSize) { final Object key = _cache.keys.first; final _CachedImage image = _cache[key]!; _currentSizeBytes -= image.sizeBytes!; image.dispose(); _cache.remove(key); } } 当缓存数量超过最大值或缓存大小超过最大缓存容量，则会清理到缓存上限以内。 obtainKey方法 Future obtainKey(ImageConfiguration configuration); 该接口主要是为了配合实现图片缓存，ImageProvider从数据源加载完数据后，会在全局的ImageCache中缓存图片数据，而图片数据缓存是一个Map，而Map的key便是调用此方法的返回值，不同的key代表不同的图片数据缓存。对应实现： @override Future obtainKey(image_provider.ImageConfiguration configuration) { return SynchronousFuture(this); } 因为Map中在判断key（此时是NetworkImage对象）是否相等时会使用\"=\"运算符，那么定义key的逻辑就是NetworkImage的“==”运算符： @override bool operator ==(Object other) { if (other.runtimeType != runtimeType) return false; return other is NetworkImage && other.url == url && other.scale == scale; } 这里可以看出key是由url+scale决定的，同一个url不同scale会重复下载。 load方法 @protected ImageStreamCompleter load(T key, DecoderCallback decode); 将密钥转换为[ImageStreamCompleter]，然后开始获取图像。 [decode]回调提供了获取图像编解码器的逻辑。 load方法的返回值类型是ImageStreamCompleter ，它是一个抽象类，定义了管理图片加载过程的一些接口，Image Widget中正是通过它来监听图片加载状态的。 MultiFrameImageStreamCompleter 是 ImageStreamCompleter的一个子类，是flutter sdk预置的类，通过该类，我们可以方便、轻松地创建出一个ImageStreamCompleter实例来做为load方法的返回值。 具体子类NetworkImage实现load @override ImageStreamCompleter load(image_provider.NetworkImage key, image_provider.DecoderCallback decode) { // Ownership of this controller is handed off to [_loadAsync]; it is that // method's responsibility to close the controller's stream when the image // has been loaded or an error is thrown. final StreamController chunkEvents = StreamController(); return MultiFrameImageStreamCompleter( codec: _loadAsync(key as NetworkImage, chunkEvents, decode), 具体_loadAsync实现 Future _loadAsync( NetworkImage key, StreamController chunkEvents, image_provider.DecoderCallback decode, ) async { try { //解析url final Uri resolved = Uri.base.resolve(key.url); //请求网络 final HttpClientRequest request = await _httpClient.getUrl(resolved); headers?.forEach((String name, String value) { request.headers.add(name, value); }); final HttpClientResponse response = await request.close(); //将HttpClientResponse的响应主体转换为Uint8List 。返回的Future将转发response发出的任何错误。 final Uint8List bytes = await consolidateHttpClientResponseBytes( response, onBytesReceived: (int cumulative, int? total) { chunkEvents.add(ImageChunkEvent( cumulativeBytesLoaded: cumulative, expectedTotalBytes: total, )); }, ); return decode(bytes); } catch (e) { //添加微任务，移除对应缓存 scheduleMicrotask(() { PaintingBinding.instance!.imageCache!.evict(key); }); rethrow; } finally { chunkEvents.close(); } } 可以看到_loadAsync方法主要做了两件事： 1.下载图片。 2.对下载的图片数据进行解码。 这里获取图片，解码图片。具体解码图片是底层做的。 @pragma('vm:entry-point') class Codec extends NativeFieldWrapperClass2 { //此类是由引擎创建的，不应直接实例化或扩展。要获取[Codec]接口的实例，请参见[instantiateImageCodec]。 @pragma('vm:entry-point') Codec._(); int? _cachedFrameCount; /// 记录该图像帧数 int get frameCount => _cachedFrameCount ??= _frameCount; int get _frameCount native 'Codec_frameCount'; int? _cachedRepetitionCount; /// 动画重复次数 /// /// * 0 动画播放一次. /// * -1 无限重复. int get repetitionCount => _cachedRepetitionCount ??= _repetitionCount; int get _repetitionCount native 'Codec_repetitionCount'; /// 获取下一个动画帧。返回最后一帧后返回到第一帧。如果解码失败，则返回的future可能会出现错误。此方法的调用者负责将[FrameInfo.image]放置在返回的对象上 Future getNextFrame() async { final Completer completer = Completer.sync(); final String? error = _getNextFrame((_Image? image, int durationMilliseconds) { if (image == null) { completer.completeError(Exception('Codec failed to produce an image, possibly due to invalid image data.')); } else { completer.complete(FrameInfo._( image: Image._(image), duration: Duration(milliseconds: durationMilliseconds), )); } }); if (error != null) { throw Exception(error); } return await completer.future; } /// 如果失败，则返回错误消息，如果成功，则返回null String? _getNextFrame(void Function(_Image?, int) callback) native 'Codec_getNextFrame'; /// 释放该对象使用的资源。调用此方法后，该对象不再可用 void dispose() native 'Codec_dispose'; } 我们可以看到Codec最终的结果是一个或多个（动图）帧，而这些帧最终会绘制到屏幕上。 另外，我们需要注意的是，图片缓存是在内存中，并没有进行本地文件持久化存储，这也是为什么网络图片在应用重启后需要重新联网下载的原因。 Image第三方控件 flutter_svg控件 对于flutter_svg这个控件，因为我们看过flutter原生的image的解析和缓存过程了，在看这个控件就很简单了。首先我们看下这个控件对外提供的几个基本的使用方法。 可以看到，对外提供了这三种加载svg的方法。 下面我们也从SvgPicture.network来了解flutter_svg的源码。 SvgPicture.network加载网络svg图片 首先看到这个方法存在于SvgPicture这个类里。 SvgPicture.network( String url, { ... }) : pictureProvider = NetworkPicture( allowDrawingOutsideViewBox == true ? svgByteDecoderOutsideViewBox : svgByteDecoder, url, headers: headers, colorFilter: svg.cacheColorFilterOverride ?? cacheColorFilter ? _getColorFilter(color, colorBlendMode) : null, ), colorFilter = _getColorFilter(color, colorBlendMode), super(key: key); 然后SvgPicture 他是一个StatefulWidget，然后这个类他必然后build和createState方法，这样我们直接去看他的build方法 @override Widget build(BuildContext context) { late Widget child; if (_picture != null) { final Rect viewport = Offset.zero & _picture!.viewport.size; ... child = SizedBox( width: width, height: height, child: FittedBox( fit: widget.fit, alignment: widget.alignment, clipBehavior: widget.clipBehavior, child: SizedBox.fromSize( size: viewport.size, child: RawPicture( _picture, matchTextDirection: widget.matchTextDirection, allowDrawingOutsideViewBox: widget.allowDrawingOutsideViewBox, ), ), ), ); ... return child; } 可以看到build是绘制的_picture然后画出来的svg图片，这里_picture是一个包含Picture的用来绘制到canvas上的实体类。 @immutable class PictureInfo { /// Creates a new PictureInfo object. const PictureInfo({ required this.picture, required this.viewport, this.size = Size.infinite, }) : assert(picture != null), // ignore: unnecessary_null_comparison assert(viewport != null), // ignore: unnecessary_null_comparison assert(size != null); // ignore: unnecessary_null_comparison Picture则是表示记录的图形操作序列的对象，可以使用[SceneBuilder]将[Picture]放置在[Scene]中。也可以使用[Canvas.drawPicture]方法将[Picture]绘制到[Canvas]中。 URL中的byte加载到PictureInfo流程 SvgPicture.network( String url, { ... }) : pictureProvider = NetworkPicture( allowDrawingOutsideViewBox == true ? svgByteDecoderOutsideViewBox : svgByteDecoder, url, headers: headers, 首先看到NetworkPicture是从PictureProvider实现过来的。 @optionalTypeArgs abstract class PictureProvider { const PictureProvider(this.colorFilter); //图片缓存 static final PictureCache cache = PictureCache(); /// 缓存个数 @Deprecated static int get cacheCount => cache.count; /// 清空缓存 @Deprecated('Use the `cache` object directly instead.') static void clearCache() => cache.clear(); /// 颜色过滤 final ColorFilter? colorFilter; /// 使用给定的configuration解析此Picture提供程序，并返回一个PictureStream 。 /// 这是PictureProvider类层次结构的公共入口点。 /// 子类应实现此方法使用的obtainKey和load PictureStream resolve(PictureConfiguration picture, {PictureErrorListener? onError}) { } /// 将pictureProvider的设置以及pictureConfiguration转换为描述要加载的精确图片的键。密钥的类型由子类确定。它是一个明确标识[load]方法将获取的图片（_包括其scale_）的值。给不同的[PictureProvider]赋予相同的构造函数参数和[PictureConfiguration]对象应互相返回==的键（可能是通过对本身实现[==]的键使用类）。 Future obtainKey(PictureConfiguration picture); /// 将密钥转换为[PictureStreamCompleter]，然后开始获取图片 @protected PictureStreamCompleter load(T key, {PictureErrorListener? onError}); } PictureProvider有三个和ImageProvider一样的方法，其实起到的作用也一样，咱们这里就不详细说了。 resole：是公共入口，里面调用了obtainKey和load方法，然后子类要实现obtainKey和load方法。 obtainKey：通过PictureConfiguration获取图片的key作为唯一标识。 load：通过key加载图片返回PictureStreamCompleter，这样一个管理图片的对象。 缓存 PictureStream resolve(PictureConfiguration picture, {PictureErrorListener? onError}) { final PictureStream stream = PictureStream(); T? obtainedKey; obtainKey(picture).then( (T key) { obtainedKey = key; stream.setCompleter( cache.putIfAbsent( key!, () => load(key, onError: onError), ), ); }, ) 这里同样是有缓存则直接用缓存文件，没有则调用load方法从网络下载。和原生ImageProvider不同的是svg缓存只有一个限制最大1000个svg图片。 const int _kDefaultSize = 1000;/// 缓存最大个数 class PictureCache { final Map _cache = {};/// 缓存队列 int get maximumSize => _maximumSize; int _maximumSize = _kDefaultSize; /// 清空缓存 void clear() { _cache.clear(); } /// 返回给定密钥的先前缓存的PictureStream （如果有）；否则，返回PictureStream 。 如果不是，则首先调用给定的回调。 在这两种情况下，密钥都将移动到“最近使用”的位置。 /// 参数不能为空。 loader无法返回null。 PictureStreamCompleter putIfAbsent( Object key, PictureStreamCompleter loader()) { PictureStreamCompleter? result = _cache[key]; if (result != null) { // 先移除，这样就能放到最近访问位置 _cache.remove(key); } else { if (_cache.length == maximumSize && maximumSize > 0) _cache.remove(_cache.keys.first); result = loader(); } if (maximumSize > 0) { assert(_cache.length _cache.length; } 可以看到这里缓存svg图片，先判断是否有缓存，如果有直接用，如果没有判断是否超过最大缓存数量限制，如果超过移除第一个然后，从网络加载，先存到缓存然后返回。 查看load实现。 @override PictureStreamCompleter load(NetworkPicture key, {PictureErrorListener? onError}) { return OneFramePictureStreamCompleter(_loadAsync(key, onError: onError),/// 一帧图片管理器 informationCollector: () sync* { yield DiagnosticsProperty('Picture provider', this);/// 图片诊断器，检测图片属性 yield DiagnosticsProperty('Picture key', key); }); } /// 下载图片 Future _loadAsync(NetworkPicture key, {PictureErrorListener? onError}) async { assert(key == this); final Uint8List bytes = await httpGet(url, headers: headers); if (onError != null) { return decoder( bytes, colorFilter, key.toString(), ).catchError((Object error, StackTrace stack) { onError(error, stack); return Future.error(error, stack); }); } return decoder(bytes, colorFilter, key.toString()); } @override bool operator ==(dynamic other) { if (other.runtimeType != runtimeType) { return false; } return other is NetworkPicture && url == other.url && colorFilter == other.colorFilter; } 同样的NetworkPicture中有通过url下载图片，最后_loadAsync返回PictureInfo，以及图片的key是由url+colorFilter组成，这样的代码。 那么bytes是怎么解析成PictureInfo的呢？ pictureProvider = NetworkPicture( allowDrawingOutsideViewBox == true ? svgByteDecoderOutsideViewBox : svgByteDecoder, url, 看到这里就很清楚了 /// A [PictureInfoDecoder] for [Uint8List]s that will clip to the viewBox. static final PictureInfoDecoder svgByteDecoder = (Uint8List bytes, ColorFilter? colorFilter, String key) => svg.svgPictureDecoder(bytes, false, colorFilter, key); /// A [PictureInfoDecoder] for strings that will clip to the viewBox. static final PictureInfoDecoder svgStringDecoder = (String data, ColorFilter? colorFilter, String key) => svg.svgPictureStringDecoder(data, false, colorFilter, key); Future svgPictureDecoder( Uint8List raw, bool allowDrawingOutsideOfViewBox, ColorFilter? colorFilter, String key, ) async { final DrawableRoot svgRoot = await fromSvgBytes(raw, key); final Picture pic = svgRoot.toPicture( clipToViewBox: allowDrawingOutsideOfViewBox == true ? false : true, colorFilter: colorFilter, ); return PictureInfo( picture: pic, viewport: svgRoot.viewport.viewBoxRect, size: svgRoot.viewport.size, ); } Future fromSvgString(String rawSvg, String key) async { final SvgParser parser = SvgParser(); return await parser.parse(rawSvg, key: key); } 然后看到这里是通过SvgParser解析得到的。到这里整个的svg图片加载实际就理顺了。 问题一：第一次加载怎么缓存到_cache里的？ 第一次load以后listener里有个_touch方法做了缓存到_cache里上代码： void _touch(Object key, _CachedImage image, TimelineTask? timelineTask) { if (image.sizeBytes != null && image.sizeBytes! 0) { _currentSizeBytes += image.sizeBytes!;///图片大小加到缓存大小里 _cache[key] = image;/// 图片添加到缓存 _checkCacheSize(timelineTask); /// 检测缓存大小 } else { image.dispose(); } } 引用流程： try { result = loader(); _trackLiveImage(key, result, null);///把图放到liveimages } catch (error, stackTrace) {} bool listenedOnce = false;/// 只监听一次标志 _PendingImage? untrackedPendingImage; void listener(ImageInfo? info, bool syncCall) { ... /// 如果初次调用resolve会触发touch if (untrackedPendingImage == null) { _touch(key, image, listenerTask); } else { image.dispose(); } ... listenedOnce = true; } final ImageStreamListener streamListener = ImageStreamListener(listener); 问题二：ExactAssetImage和AssetImage区别？ 从表达式就能看出 scale != null ? ExactAssetImage(name, bundle: bundle, scale: scale, package: package) : AssetImage(name, bundle: bundle, package: package) 有scale用ExactAssetImage，没有用AssetImage，具体区别其实是，AssetImage会自动根据使用场景的设备参数，屏幕像素比自动使用对应1x还是2x,3x的图片。而ExactAssetImage则忽略设备像素比，通过给定的确切assetName和scale来获取图片 Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2021-06-02 10:52:45 "},"flutter/Flutter源码/inheritedWidget/InheritedWidget.html":{"url":"flutter/Flutter源码/inheritedWidget/InheritedWidget.html","title":"InheritedWidget","keywords":"","body":"组件状态共享 在Flutter的框架中，使用InheritedWidget来实现Widget之间的信息共享。InheritedWidget被描述为在树中高效向下传递信息的Widget基类。使用InheritedWidget我们能够实现： 为子组件提供数据共享。 为子组件提供响应式更新。 简单实例 代码片段 @override Widget buildPage(BuildContext context) { Color a = Theme.of(context).accentColor; .... } Theme使用_InheritedTheme来完成它的状态共享，_InheritedTheme是InheritedWidget的实现。 如何实现数据共享 如何在Element树中存储需要共享的数据 Flutter框架在InheritedElement挂载时将数据关联起来，以首次mount为例： 关键方法：_updateInheritance有两个实现，一个在Element，一个在InheritedElement。 //Element void _updateInheritance() { assert(_lifecycleState == _ElementLifecycle.active); _inheritedWidgets = _parent?._inheritedWidgets; } //InheritedElement @override void _updateInheritance() { assert(_lifecycleState == _ElementLifecycle.active); final Map? incomingWidgets = _parent?._inheritedWidgets; if (incomingWidgets != null) _inheritedWidgets = HashMap.from(incomingWidgets); else _inheritedWidgets = HashMap(); _inheritedWidgets![widget.runtimeType] = this; } 整个流程组合起来实现了一件事：每个Element会维护一张_inheritedWidgets表，这张表包括了从自身开始到Element树Root这条路径上所有InheritedElement的{widget.runtimeType,InheritedElement}映射。 子Element如何查询到相应数据 BuildContext提供了两种查询接口： T? dependOnInheritedWidgetOfExactType({Object? aspect})：这种查询方式会让自己在InheritedElement更新时，更新自己的展示。将Element自己添加到了_dependencies。 InheritedElement? getElementForInheritedWidgetOfExactType()：单纯的查询InheritedElement。 这两种的实现都在Element: @override InheritedWidget dependOnInheritedElement(InheritedElement ancestor, { Object? aspect }) { assert(ancestor != null); _dependencies ??= HashSet(); _dependencies!.add(ancestor); //添加数据依赖，以便InheritedWidget数据发生改变后，更新页面。 ancestor.updateDependencies(this, aspect); return ancestor.widget; } @override T? dependOnInheritedWidgetOfExactType({Object? aspect}) { assert(_debugCheckStateIsActiveForAncestorLookup()); final InheritedElement? ancestor = _inheritedWidgets == null ? null : _inheritedWidgets![T]; if (ancestor != null) { assert(ancestor is InheritedElement); return dependOnInheritedElement(ancestor, aspect: aspect) as T; } _hadUnsatisfiedDependencies = true; return null; } @override InheritedElement? getElementForInheritedWidgetOfExactType() { assert(_debugCheckStateIsActiveForAncestorLookup()); final InheritedElement? ancestor = _inheritedWidgets == null ? null : _inheritedWidgets![T]; return ancestor; } abstract class InheritedWidget extends ProxyWidget { const InheritedWidget({ Key? key, required Widget child }) : super(key: key, child: child); @override InheritedElement createElement() => InheritedElement(this); // 当此方法返回false是，不会更新child。 @protected bool updateShouldNotify(covariant InheritedWidget oldWidget); } 数据改变如何通知更新 我们知道，所有的Widget都是@immutable。那么改变InheritedWidget的一种方式是父Widget标dirty，用新的数据从新生成InheritedWidget。 最后一个流程：InheritedElement.notifyClients()源码如下，又回到_dependencies找到元素，并标记dirty。 //InheritedWidget @override void notifyClients(InheritedWidget oldWidget) { assert(_debugCheckOwnerBuildTargetExists('notifyClients')); for (final Element dependent in _dependents.keys) { assert(() { // check that it really is our descendant Element? ancestor = dependent._parent; while (ancestor != this && ancestor != null) ancestor = ancestor._parent; return ancestor == this; }()); // check that it really depends on us assert(dependent._dependencies!.contains(this)); notifyDependent(oldWidget, dependent); } } //Element void rebuild() { assert(_lifecycleState != _ElementLifecycle.initial); //下面这个判断当_dirty为false时，不继续流程。 if (_lifecycleState != _ElementLifecycle.active || !_dirty) return; ....... } 应用实例 Theme Theme是一个StatelessWidget类型的组件，存储Theme数据的是一个final类型的ThemeData变量。而且ThemeData也被标记为@immutable。那么就很明显了，不存在单独改变某个ThemeData的属性来修改Theme的情况，只能重新构建Theme对象来改变属性。 //将ThemeData与字体相关的本地化配置合并生成新的ThemeData返回给用户。 static ThemeData of(BuildContext context) { final _InheritedTheme? inheritedTheme = context.dependOnInheritedWidgetOfExactType(); final MaterialLocalizations? localizations = Localizations.of(context, MaterialLocalizations); final ScriptCategory category = localizations?.scriptCategory ?? ScriptCategory.englishLike; final ThemeData theme = inheritedTheme?.theme.data ?? _kFallbackTheme; return ThemeData.localize(theme, theme.typography.geometryThemeFor(category)); } @override Widget build(BuildContext context) { return _InheritedTheme( theme: this, child: CupertinoTheme( data: MaterialBasedCupertinoThemeData( materialTheme: data, ), child: IconTheme( data: data.iconTheme, child: child, ), ), ); } Theme默认值 在ThemeData的构造方法中有很多判空，并给定默认值：primarySwatch ??= Colors.blue; Theme的使用 从代码结构来看，ThemeData并没有传递性，如果你想用一个新的局部Theme来改变全局Theme的某一个属性是做不到的。新Theme的child不能能查询到全局Theme的ThemeData。 系统默认使用：在很多系统组件中，某些属性如果没有赋值，那么会自动查询Theme赋值，例如TextFormField：final InputDecoration effectiveDecoration = (decoration ?? const InputDecoration()).applyDefaults(Theme.of(field.context).inputDecorationTheme); 主动使用：Theme.of(context)获取ThemeData，直接使用属性即可。 Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2021-05-31 15:44:12 "},"flutter/Flutter源码/intl/internationalization.html":{"url":"flutter/Flutter源码/intl/internationalization.html","title":"Flutter国际化","keywords":"","body":"Flutter 国际化 详情链接 1：让App支持多语言 需要我们在开发时需要为应用程序支持的每种语言环境设置“本地化”的一些值，如文本和布局。 Flutter SDK已经提供了一些组件和类来帮助我们实现国际化。这里主要是指 文案（字符串） 支持国际化 1：我们以MaterialApp为入口，大多数应用都是通过MaterialApp为入口。 2：Flutter SDK 默认支持美国英语本地化资源（主要是文本），其他语言需要添加包依赖 flutter_localizations。 3：指定MaterialApp的 localizationsDelegates和 supportedLocales。 dependencies: flutter: sdk: flutter flutter_localizations: sdk: flutter import 'package:flutter_localizations/flutter_localizations.dart'; new MaterialApp( localizationsDelegates: [ // 本地化的代理类 GlobalMaterialLocalizations.delegate, //PS: 基于WidgetsApp类为入口的应用程序进行国际化时, 不需要这个 GlobalWidgetsLocalizations.delegate,// 定义组件默认的文本方向，从左到右或从右到左. GlobalCupertinoLocalizations.delegate, ], supportedLocales: [ // 当前应用支持的locale列表 const Locale('en', 'US'), // 美国英语 const Locale('zh', 'CN'), // 中文简体 //其它Locales ], // ... ) 获取当前区域Locale。 PS: 不太好用。 Locale locale = Localizations.localeOf(context); 手动指定local Widget widget1 = MaterialApp( locale: const Locale('en', 'US'),//手动指定locale ); 监听系统语言切换 当我们更改系统语言设置时，APP中的Localizations组件会重新构建，Localizations.localeOf(context) 获取的Locale就会更新，最终界面会重新build达到切换语言的效果，但是这个过程是隐式完成的。 我们可以通过localeResolutionCallback或localeListResolutionCallback回调来监听locale改变的事件。 Widget widget1 = MaterialApp( // typedef LocaleResolutionCallback = Locale? Function(Locale? locale, Iterable supportedLocales); localeResolutionCallback: (Locale? locale, Iterable supportedLocales){ //local: 当前的当前的系统语言设置 //supportedLocales: 为当前应用支持的locale列表，是开发者在MaterialApp中通过supportedLocales属性注册的 // return Locale? }, // typedef LocaleListResolutionCallback = Locale? Function(List? locales, Iterable supportedLocales); localeListResolutionCallback: (List? locales, Iterable supportedLocales){ //local: 当前的当前的locales 列表 //supportedLocales: 为当前应用支持的locale列表，是开发者在MaterialApp中通过supportedLocales属性注册的 // return Locale? }, ); } Localization组件 Localizations组件用于加载和查找应用当前语言下的本地化值或资源。应用程序通过Localizations.of(context,type) (opens new window)来引用这些对象。 如果设备的Locale区域设置发生更改，则Localizations 组件会自动加载新区域的Locale值，然后重新build使用（依赖）了它们的组件，之所以会这样，是因为Localizations内部使用了InheritedWidget (opens new window)，该组件：当子组件的build函数引用了InheritedWidget时，会创建对InheritedWidget的隐式依赖关系。因此，当InheritedWidget发生更改时，即Localizations的Locale设置发生更改时，将重建所有依赖它的子组件。 使用系统打包好的LocalizationDelegates 为了尽可能小而且简单，flutter软件包中仅提供美国英语值的MaterialLocalizations和WidgetsLocalizations接口的实现。 ps: GlobalCupertinoLocalizations也提供了。 如果我们要让自己的布局支持多语言，那么就需要实现自己的Localizations。 主要源码： abstract class LocalizationsDelegate { const LocalizationsDelegate(); bool isSupported(Locale locale); Future load(Locale locale); bool shouldReload(covariant LocalizationsDelegate old); Type get type => T; @override String toString() => '${objectRuntimeType(this, 'LocalizationsDelegate')}[$type]'; } 2：实现自定义Localizations static const LocalizationsDelegate delegate = _MaterialLocalizationsDelegate(); 自定义实现Localizations 我们需要实现两个类：一个Delegate类一个Localizations类。 实现Localizations类 //Locale资源类 class DemoLocalizations { DemoLocalizations(this.isZh); //是否为中文 bool isZh = false; //为了使用方便，我们定义一个静态方法 static DemoLocalizations of(BuildContext context) { return Localizations.of(context, DemoLocalizations); } //Locale相关值，title为应用标题 String get title { return isZh ? \"Flutter应用\" : \"Flutter APP\"; } //... 其它的值 } 实现Delegate类 Delegate类的职责是在Locale改变时加载新的Locale资源，所以它有一个load方法，Delegate类需要继承自LocalizationsDelegate类，实现相应的接口 //Locale代理类 class DemoLocalizationsDelegate extends LocalizationsDelegate { const DemoLocalizationsDelegate(); //是否支持某个Local @override bool isSupported(Locale locale) => ['en', 'zh'].contains(locale.languageCode); // Flutter会调用此类加载相应的Locale资源类 @override Future load(Locale locale) { print(\"$locale\"); return SynchronousFuture( DemoLocalizations(locale.languageCode == \"zh\") ); } @override bool shouldReload(DemoLocalizationsDelegate old) => false; } 添加多语言支持 先注册DemoLocalizationsDelegate类，然后再通过DemoLocalizations.of(context)来动态获取当前Locale文本。 localizationsDelegates: [ // 本地化的代理类 GlobalMaterialLocalizations.delegate, GlobalWidgetsLocalizations.delegate, // 注册我们的Delegate DemoLocalizationsDelegate() ], 食用: return Scaffold( appBar: AppBar( //使用Locale title title: Text(DemoLocalizations.of(context).title), ), ... //省略无关代码 ） 3：捷径— 使用Intl包 dependencies: #...省略无关项 intl: ^0.15.7 dev_dependencies: #...省略无关项 intl_translation: ^0.17.2 intl_translation (opens new window)包主要包含了一些工具，它在开发阶段主要的作用是从代码中提取要国际化的字符串到单独的arb文件和根据arb文件生成对应语言的dart代码。 intl包主要是引用和加载intl_translation生成后的dart代码。 食用详情 简单步骤： 创建必要目录，包含arb文件 实现Localizations和Delegate类，使用Intl包中方法。 添加需要国际化的属性 生成arb文件，通过命令 生成Dart代码，通过命令 合成命令脚本 4：超捷径 插件Intl Flutter Intl 插件食用 简洁好用。 附赠：language code list country code list 5：国际化一般会碰到的问题 1：应用标题国际化 2：为英语系国家指定同一个locale Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2021-06-02 10:47:30 "},"GLOSSARY.html":{"url":"GLOSSARY.html","keywords":"","body":"MoonTools 皓月开发工具,参考 MoonTools moon-tools 皓月开发工具,参考 MoonTools Project 在AS中作为整个工作环境存在，可以包含多个Module。 Module 在AS中作为真正的开发的内容存在，是一个个独立功能的单元模块，可以被其他Module依赖。 kit-upgrade kit库更新日志，参见kit更新文档 KitImport kit库更新日志，参见kit引入文档 Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2021-05-18 15:34:59 "}}