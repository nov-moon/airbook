{"./":{"url":"./","title":"简介","keywords":"","body":"简介 本文档是平时学习工作中对各类知识的总结。 运行 安装 GitBooknpm install gitbook-cli -g Clone 代码到本地并运行gitbook install gitbook serve 在浏览器中打开 http://localhost:4000/ 进行访问 可以使用gitbook build ./ ./docs命令，生成静态网页，并指定docs为生成目录，而不是默认的_book。因为我们的Github Pages使用的是docs目录，所以发布需要使用此命令 发布 --测试环境 https://github.com/nov-moon/airbook https://nov-moon.github.io/airbook Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2021-05-21 18:47:50 "},"flutter/第三方框架/":{"url":"flutter/第三方框架/","title":"Flutter-第三方库","keywords":"","body":"第三方库 本文档主要包括常用第三方库的源码阅读与分享 Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2021-05-19 11:32:09 "},"flutter/第三方框架/GetX/":{"url":"flutter/第三方框架/GetX/","title":"GetX","keywords":"","body":"GetX GetX是Flutter中比较流行的框架，主要提供：路由管理、依赖管理、状态管理。 官方地址：https://github.com/jonataslaw/getx/blob/master/README.zh-cn.md Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2021-05-19 11:32:09 "},"flutter/第三方框架/GetX/GetX（一）.html":{"url":"flutter/第三方框架/GetX/GetX（一）.html","title":"从官方demo开始","keywords":"","body":"GetX（一）从demo开始 Flutter是响应式编程架构，在Flutter开发中，经常遇到如何便捷的更新状态和如何方便快捷的传递上下文共享数据。 GetX提供了相应功能。 在GetX的官方demo中，演示了如何便捷高效的更新UI： class HomePage extends StatelessWidget { final model = CountModel(); @override Widget build(BuildContext context) { return Scaffold( // 使用Obx(()=>每当改变计数时，就更新Text()。 appBar: AppBar(title: Obx(() => Text(\"Clicks: ${model.count}\"))), body: Center(), floatingActionButton: FloatingActionButton( child: Icon(Icons.add), onPressed: () => model.count++, )); } } class CountModel { var count = 0.obs; } 在上述代码中，更改了部分官方代码，以便简化代码，突出重点 在上述代码中我们看到，我们使用了一个StatelessWidget，做到了UI更新，非常的神奇。 上面的代码和我们平时动态更新ui的代码有三处不同：CountModel中的0.obs、使用了StatelessWidget、Obx(() => Text(\"Clicks: ${model.count}\"))。 下面我们对新出现的obs和Obx实现进行学习，尝试解开其中神奇的魔力来源。 0.obs中的魔法 看到GetX中0.obs语法，那么他必然是使用了Dart中的扩展语法，源码如下： // rx_impl.dart extension IntExtension on int { /// Returns a `RxInt` with [this] `int` as initial value. RxInt get obs => RxInt(this); } extension StringExtension on String { /// Returns a `RxString` with [this] `String` as initial value. RxString get obs => RxString(this); } extension DoubleExtension on double { /// Returns a `RxDouble` with [this] `double` as initial value. RxDouble get obs => RxDouble(this); } extension BoolExtension on bool { /// Returns a `RxBool` with [this] `bool` as initial value. RxBool get obs => RxBool(this); } extension RxT on T { /// Returns a `Rx` instace with [this] `T` as initial value. Rx get obs => Rx(this); } 从上述源码可知，GetX支持String、Int、Double、Bool、T，所以任意类型都可以使用 .obs 。 以int为例，进一步看一下具体实现。 我们知道，在Dart中一个类可以通过extends、implement、mixin三种方式集成其他类的功能。如果单说继承不足以描述三种实现方式。extends是传统的继承方式，implements是传统的接口实现方式，mixin是Dart中直接集成其他类功能的方式。 当我们调用0.obs时，他的返回类型其实为RxInt。 而RxInt类的继承关系如下图： 其实其他的RxString、RxDouble、RxBool、Rx都是_RxImpl的子类，而其中的间接父类只是提供了对应类型的自有能力，例如RxInt可以支持加减乘除等数字操作，而这些能力来源于间接父类_BaseRxNum和他本身。 所以我们可以猜到，_RxImpl其实是支持魔法的根源。 _RxImpl类分两部分组成，mixin进来的RxObjectMixin和继承进来的RxNotifier。 RxNotifier 首先我们看一下RxObjectMixin，代码如下： // 绑定的数据 T _value; // 刷新，转入了subject方法 void refresh() { subject.add(value); } // 设置空值 void nil() { subject.add(_value = null); } // 提供直接括号的语法糖调用方式 T call([T v]) { if (v != null) { value = v; } return value; } // .... 省略了一些hash == 等方法 // 设置value，如果不是首次build，并且值相同则不更新。 // 将新的value转入subject set value(T val) { if (_value == val && !firstRebuild) return; firstRebuild = false; _value = val; subject.add(_value); } // 当获取value时，查看proxy是否为null，不为null时则使用subject监听proxy T get value { if (RxInterface.proxy != null) { RxInterface.proxy.addListener(subject); } return _value; } 从上面的代码可知，RxObjectMixin提供了数据绑定以及方便的刷新等方法。 而subject不属于RxObjectMixin类，则他必然来自RxNotifier。 这里需要注意的是value的get方法中的RxInterface.proxy，后面我们会再遇到RxInterface.proxy。 RxNotifier 通过上面的分析可知，RxInt数据绑定的能力来自RxObjectMixin，那么他数据监听和更新的能力，必然来自RxNotifier(只有两个父类，所以另一部分能力必然来自它)。 由上图可知，RxNotifier实现了RxInterface接口，而RxNotifier的代码如下： class RxNotifier = RxInterface with NotifyManager; 我们看到，RxNotifier并没有自己的实体，所以接口RxInterface定义的方法，都由NotifyManager实现。 而NotifyManager类确实实现了RxInterface功能定义，大体源码如下： // 低层的监听果然使用的是流 GetStream subject = GetStream(); // 流的订阅者 final _subscriptions = >{}; bool get canUpdate => _subscriptions.isNotEmpty; // 将当前stream的add回调，添加到入参流rxGetx的事件监听中。当rxGetx发生变化时会回调subject.add，并将订阅者添加到_subscriptions中，以便关闭和资源回收。 void addListener(GetStream rxGetx) { if (!_subscriptions.containsKey(rxGetx)) { final subs = rxGetx.listen(subject.add); final listSubscriptions = _subscriptions[rxGetx] ??= []; listSubscriptions.add(subs); } } // 添加事件流更改时的监听 StreamSubscription listen( void Function(T) onData, { Function onError, void Function() onDone, bool cancelOnError = false, }) => subject.listen(onData, onError: onError, onDone: onDone, cancelOnError: cancelOnError); // 关闭订阅者等资源 void close() { .... } 从上述源码中可知，RxNotifier提供了两个东西：真正的流GetStream、将其他GetStream的事件变更转发到当前持有的GetStream。 由此可知GetStream提供了所有的流事件的管理和分发。 GetStream GetStream提供了一系列的监听方法，用于对流的状态监听。提供了一系列的管理方法，用于管理订阅者和事件分发。源码如下： class GetStream { // 当添加新的监听时的回调方法 void Function() onListen; // 当订阅者暂停时的回调 void Function() onPause; // 当订阅者恢复时的回调 void Function() onResume; // 当前流cacenl时的回调 FutureOr Function() onCancel; // 为当前流移除订阅者 FutureOr removeSubscription(LightSubscription subs); // 为当前流添加订阅者 FutureOr addSubscription(LightSubscription subs); // 数据变化时更新所有订阅者 void _notifyData(T data); // 发生错误时，通知所有订阅者 void _notifyError(Object error, [StackTrace stackTrace]); // 流完成时通知订阅者 void _notifyDone(); // 当前流最后一个事件对象 T _value; // 添加事件 void add(T event) { _value = event; // 转发到_notifyDate() _notifyData(event); } // 给当前流添加新的监听 LightSubscription listen(void Function(T event) onData,{Function onError, void Function() onDone, bool cancelOnError}) { final subs = LightSubscription(removeSubscription,onPause: onPause,onResume: onResume,onCancel: onCancel,) ..onData(onData) ..onError(onError) ..onDone(onDone) ..cancelOnError = cancelOnError; addSubscription(subs); onListen?.call(); return subs; } // 将GetStream转化为流的方式返回。 Stream get stream => GetStreamTransformation(addSubscription, removeSubscription); } 在上述源码中，使用到了LightSubscription，他只是对订阅者的简单封装，有兴趣的同学可以自行查看。 至此通过源码发现，所有的可观察类都是_RxImpl的子类，他提供了数据绑定(RxObjectMixin)和数据变化时的事件管理和分发(RxNotifier)的能力。 然而事件分发给谁呢？我们根据counter功能大胆推测一下，数据的变更事件可能都分发给了Obx()，从而促使Obx进行更新，最终UI更新。 Obx(() => Text(\"Clicks: ${model.count}\")) 在Flutter中，如果需要更新UI，在不使用黑魔法的前提下，我们推测GetX内部大概率同样使用了StatefulWidget。 通过源码可知，Obx的继承关系为：Obx -> ObxWidget -> StatefulWidget。 到此可知，Obx的更新确实是基于StatefulWidget。 ObxWidget对应的State为_ObxState，源码如下： class _ObxState extends State { // 当前持有的观察者对象 RxInterface _observer; // 当前的订阅者对象 StreamSubscription subs; _ObxState() { // RxNotifier上文提到过，提供了事件的监听管理和分发 _observer = RxNotifier(); } @override void initState() { // 对观察者添加监听，当_observer内容发生变化时，触发_updateTree subs = _observer.listen(_updateTree); super.initState(); } // 调用setState触发更新 void _updateTree(_) { if (mounted) { setState(() {}); } } // 关闭观察者，取消订阅者 @override void dispose() { subs.cancel(); _observer.close(); super.dispose(); } // 调用widget中的build，更新child。 Widget get notifyChilds { final observer = RxInterface.proxy; RxInterface.proxy = _observer; final result = widget.build(); if (!_observer.canUpdate) { // 抛出错误，省略... } RxInterface.proxy = observer; return result; } @override Widget build(BuildContext context) => notifyChilds; } 通过上面的源码可知，_ObxState基本上都是对_observer的监听等操作的处理。 当_observer发生变化时，更新当前widget。当前widget回收时，关闭_observer并取消订阅者。 然而并没有发现counter更改时，如何触发widget更改。 我们在分析RxObjectMixin的源码时曾经看到其中_value的get方法，有一段如下源码： // 当获取value时，查看proxy是否为null，不为null时则使用subject监听proxy T get value { if (RxInterface.proxy != null) { RxInterface.proxy.addListener(subject); } return _value; } 而_ObxState中的notifyChilds方法为： // 调用widget中的build，更新child。 Widget get notifyChilds { final observer = RxInterface.proxy; RxInterface.proxy = _observer; final result = widget.build(); if (!_observer.canUpdate) { // 抛出错误，省略... } RxInterface.proxy = observer; return result; } 在此方法中，同样有对RxInterface.proxy的操作。他将原来的proxy存入临时变量，并将当前_observer设置为全局proxy，再调用build。完成以后再恢复原始proxy。一顿蜜汁操作。。。 我们看一下在notifyChilds方法的具体调用链路，如下： 如上图所示，在（3）中_ObxState将proxy设置为_observer，而在（6）中Text(\"Clicks: ${model.count}\")，系统会将String拼串操作转换为Text(\"Clicks: ${model.count.toString()}\")，触发了（7）的toString()，而toString()的实现为：value.toString()，使用了value对象，从而触发了value的get方法（8）、（9），在get方法中使用（3）中设置的_observer(_ObxState中的对象)监听当前counter上的事件变更。一系列调用完成后，在（13）中再将proxy恢复成原始proxy。 这也解释了在notifyChilds()方法中替换proxy的蜜汁操作。 当_ObxState回收时，同时回收事件订阅器，以及关闭当前_observer对象。 总结 我们从头再理一下思路。 count通过扩展的方式，获取到了一个支持数据绑定(RxObjectMixin)和数据事件分发(RxNotifier)的Rx对象。 当系统构建UI时，调用_ObxState的build()方法，从而以隐式的方式调用count.toString()方法，而RxObjectMixin.toString()方法又隐式的调用了value的get方法。在get方法中，由于之前的proxy交换操作，致使当前proxy为当前_ObxState._observer，最终将value的数据变更流整合到了_ObxState._observer中。 当count变更时，触发他自己的事件流，同时触发_ObxState._observer的事件流，最终更新UI。 这一步proxy变换和value的get操作，堪称神来之笔，膜拜~ 同时，通过源码可知，在Obx的build回调中不可轻易更改proxy，否则将导致proxy链接到的对象错误，从而导致不能正确分发事件，不能更新UI。 但是在Obx中可同时多层嵌套Obx，因为每次build时都会恢复成之前的proxy。 思考 如果在Rx对象中不使用Stream 其实在Rx对象的实现中并没有直接使用Stream，GetStream也只是借鉴了Stream的事件思想以及分发套路。value值的变更是事件的原动力，每次变更都会对应一次事件的生成。同时又需要将事件分发给所有的订阅者们，以便订阅者更新自己。这个套路就是Stream的广播订阅模式。 为什么不使用Stream 虽然GetStream叫Stream，但是他并不是Stream的子类。作为Flutter中的基础框架类，Stream提供的能力更加庞杂，更加多变。然而GetStream并不需要这么庞杂的能力，只需要聚焦到事件管理和分发就可以了。 如果有更多的更新元素 我们通过源码分析可以知道，每个可更新元素都对应两个NotifyManager，两个GetStream，每多增加一个Obx都会增加一套相应的对象用来完成订阅。而每套对象中又包含相应的配套对象。虽然多次调用setState并不会触发帧的更新，但是仍然会有很多对象生成，以及很多关联调用。例如在列表更新中，GetX提供了GetBuilder和GetX用于批量更新。那让我们看一下他是如何提高效率的。 Get.put(instance)分析 GetxController GetxController类提供了两个功能：生命周期管理、广播内容变化 对于生命周期管理，它继承了GetLifeCycleBase类，提供了：onInit()、onReady()、onClose()。 onInit()回调方法在当前controller被加载到内存中后，第一时间调用。 onReady()方法在下一帧刷新时调用，一般用来处理dialog之类需要下一帧时机 onClose()方法用来处理一些资源回收。 对于广播内容变化功能，GetxController提供了update()方法，用于更新订阅者。 put()方法实现 通过调用put()方法，将实例添加到了GetX中名为_singl的静态map中，再直接通过find()方法返回传入实例。 find()方法，会从_singl中查找，并检查是否已经初始化。 如果未初始化，则直接调用传入的build方法(如果没有传入build则默认生成一个build方法，返回传入的实例)，获取实例。 获取完成实例以后，会检查当前实例是否为GetLifeCycleBase类型，我们前面分析GetxController类时已经说明，他通过继承GetLifeCycleBase，提供了生命周期方法。 如果当前实例为GetLifeCycleBase类型，则调用其onStart()回调方法 尝试将当前route引用加入到route列表中 Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2021-05-19 11:32:09 "},"flutter/第三方框架/GetX/GetX（二）.html":{"url":"flutter/第三方框架/GetX/GetX（二）.html","title":"GetxController和GetX","keywords":"","body":"GetX（二）GetxController和GetX 在上文中的官方demo部分，我们贴出的源码是简单改动过的。 而改动的部分主要是将CountModel由GetxController的子类，更换为了普通对象。 下面我们一块学习一下GetxController源码。 1. GetxController的实现 先不说其他，先看一下GetxController的继承结构，如下图： 由上图可知，GetxController通过继承DisposableInterface和mixin ListNotifier的方式，提供了生命周期和批量更新的能力。 DisposableInterface DisposableInterface通过继承GetLifeCycle，提供了如下生命周期方法： onStart 虽然是Function类型，但是以final变量的方式存在，用来防止子类重写。本方法将在widget被加载到内存中时由框架调用。此方法的默认实现会检查是否已经初始化，如果没有，则调用onInit()方法，所以多次调用onStart，只会执行一次onInit() onInit() 本方法会在widget被加载到内存中后调用。一般用来初始化一些后续需要使用的对象。 onReady() 此方法会比onInit()方法晚调用一帧，此方法一般用于执行snackbar、新的路由等需要页面init完成后执行的操作。 onDelete 和onStart很类似，也是用于框架调用的final变量类型的Function。默认会关联调用onClose()，并且执行多次，也只会执行一次onClose()。 onClose() 此方法用于回收资源，类似Widget中的dispose方法。 对于onReady()方法的描述，我们知道他会在onInit()的下一帧调用，我们看一下源码的实现方式： @override @mustCallSuper void onInit() { super.onInit(); SchedulerBinding.instance?.addPostFrameCallback((_) => onReady()); } 我们看到要达到这个效果，这里使用的是SchedulerBinding.instance?.addPostFrameCallback的方式，类似的还有addPersistentFrameCallback方法，有兴趣的童鞋可以了解一下Flutter的加载流程。 ListNotifier 既然是一起看源码，那先上酸菜： class ListNotifier implements Listenable { // 忽略了部分不重要的代码 List _updaters = []; HashMap> _updatersGroupIds = HashMap>(); @protected void refresh() { if (_microtask == _version) { _microtask++; // 异步更新 scheduleMicrotask(() { _version++; _microtask = _version; _notifyUpdate(); }); } } // 简单的更新逻辑 void _notifyUpdate() { for (var element in _updaters) { element(); } } // 按照组id进行更新 void _notifyIdUpdate(Object id) { if (_updatersGroupIds.containsKey(id)) { final listGroup = _updatersGroupIds[id]; for (var item in listGroup) { item(); } } } @protected void refreshGroup(Object id) { // 异步更新 if (_microtask == _version) { _microtask++; scheduleMicrotask(() { _version++; _microtask = _version; _notifyIdUpdate(id); }); } } // 在更新队列_updaters中添加setState方法 @protected void notifyChildrens() { TaskManager.instance.notify(_updaters); } // 删除了部分增加、删除监听的方法 } 由上面的源码可知，ListNotifier提供了两种注册方式：以单个的方式注册更新、以组的方式注册更新。 我们知道Flutter是单线程运行的，在Flutter启动过程中会维护两个队列：EventQueue和MicroTaskQueue。 每次ticker触发时，都会执行两个队列，其中MicroTaskQueue的优先级要高于EventQueue。只有当task执行完成以后，才会执行EventQueue中的内容。 这里使用scheduleMicrotask()方法执行具体的更新操作，可以不阻塞调用方，将具体更新放到下次ticker执行，并且在下次绘制之前得到执行。 2. GetX的自动更新 GetX的官方demo中是这样介绍GetX的： // controller final count1 = 0.obs; final count2 = 0.obs; int get sum => count1.value + count2.value; // 视图 GetX( builder: (controller) { print(\"count 1 rebuild\"); return Text('${controller.count1.value}'); }, ), GetX( builder: (controller) { print(\"count 2 rebuild\"); return Text('${controller.count2.value}'); }, ), GetX( builder: (controller) { print(\"count 3 rebuild\"); return Text('${controller.sum}'); }, ), 如果我们把count1.value++递增，就会打印出来： count 1 rebuild count 3 rebuild 如果我们改变count2.value++，就会打印出来。 count 2 rebuild count 3 rebuild 因为count2.value改变了，sum的结果现在是2。 从Demo看，可能会有三个问题： GetX是如何做到自动更新的？ Controller和GetX是如何交互的？ sum没有使用Rx，但是count1、count2更新时，他同样触发了更新，是如何做到的？ 在看源码的过程中，带着这三个问题，我们一步步寻找答案。 2.1. GetX的自动更新 我们前一篇已经分析过Obx是如何自动更新的，我们已经了解到Obx是如何巧妙的使用全局proxy替换，以及如何巧妙的使用Rx对象的get方法。 我们推测GetX也是基于StatefulWidget的能力进行的UI重绘，也是使用了相同的套路进行事件流监听。 GetX的源码如下： class GetX extends StatefulWidget { final GetXControllerBuilder builder; final bool global; final bool autoRemove; final bool assignId; final void Function(State state) initState, dispose, didChangeDependencies; final void Function(GetX oldWidget, State state) didUpdateWidget; final T init; final String tag; const GetX({ this.tag, this.builder, this.global = true, this.autoRemove = true, this.initState, this.assignId = false, this.dispose, this.didChangeDependencies, this.didUpdateWidget, this.init, }); @override GetXState createState() => GetXState(); } 从上述源码可见： GetX确实是使用的StatefulWidget进行的UI更新 GetX的入参泛型T是DisposableInterface的子类，而DisposableInterface我们前面已经分析过，他主要提供声明周期的功能。所以T类型时具有声明周期的类型，可以是GetXController类型。 GetX提供了一些类似State中的回调方法，用于将State回调时机给到使用方。 GetX还提供了诸如global、tag等入参，我们通过对State的分析，再看具体作用。 从上述源码可以看到GetX是StatefulWidget，对应GetXState类，我们再详细看一下其中的源码： class GetXState extends State> { GetXState() { _observer = RxNotifier(); } RxInterface _observer; // 省略部分代码 Widget get notifyChildren { final observer = RxInterface.proxy; RxInterface.proxy = _observer; final result = widget.builder(controller); if (!_observer.canUpdate) { throw \"错误提示\"; } RxInterface.proxy = observer; return result; } @override Widget build(BuildContext context) => notifyChildren; } 从上述源码可知，和我们推测的一致，GetX也使用了proxy的交换技巧，用以远端设置观察者。 2.2. GetX和GetxController的交互 除了上述源码，State中还有一部分源码，用于和Controller进行交互，如下： // GetXState源码 T controller; bool isCreator = false; StreamSubscription subs; @override void initState() { // 1 var isRegistered = GetInstance().isRegistered(tag: widget.tag); // 2 if (widget.global) { if (isRegistered) { if (GetInstance().isPrepared(tag: widget.tag)) { isCreator = true; } else { isCreator = false; } controller = GetInstance().find(tag: widget.tag); } else { controller = widget.init; isCreator = true; GetInstance().put(controller, tag: widget.tag); } } else { // 3 controller = widget.init; isCreator = true; controller?.onStart(); } // 4 widget.initState?.call(this); if (widget.global && Get.smartManagement == SmartManagement.onlyBuilder) { controller?.onStart(); } // 5 subs = _observer.listen((data) => setState(() {})); super.initState(); } 上述代码的作用如下： GetInstance类提供了跨页面的实例共享与管理。我们暂且不讨论。isRegistered()方法用于判断指定类型下的指定tag对象是否已经在框架中注册。 controller对象如果是全局对象(global=true)，则再检查对象是否已准备就绪。在GetInstance中，如果一个对象已经被init或者对象没有被注册，isPrepared()都会返回false，所以这里先使用isRegistered()确保对象已经被注册，然后使用isPrepared()判断对象是否已经被加载。 如果被加载，则标记controller的创建者为当前state，也就是isCreator=true。 则使用widget.init初始对象，注册到Get中，并设置isCreator=true 如果controller对象是局部对象(global=false)，并且直接将widget.init设置为controller，并调用他的onStart()方法，开启生命周期。 我们在分析GetXController的时候知道，onStart()会调用onInit()方法，所以Controller.onInit()对应State.onInit()。而onReady()方法会在下一帧调用，也就是会在onInit()之后调用。 Get.smartManagement是对GetX中共享对象的管理策略，我们暂时不讨论。 设置当observer的数据流发生变化时，调用setState。和Obx中相似，但是Obx判断了当前State的状态，感觉Obx中的处理会更安全。 其实GetX控件中还有部分代码没有贴出来，基本上都是转发didChangeDependencies()之类的，以及dispose的时候，根据isCreator，是否移除controller对象。 看完GetState的源码以后，我们回过头再仔细看一下GetX的定义： class GetX extends StatefulWidget { final GetXControllerBuilder builder; final bool global; final bool autoRemove; final bool assignId; final void Function(State state) initState, dispose, didChangeDependencies; final void Function(GetX oldWidget, State state) didUpdateWidget; final T init; final String tag; const GetX({ this.tag, this.builder, this.global = true, this.autoRemove = true, this.initState, this.assignId = false, this.dispose, this.didChangeDependencies, this.didUpdateWidget, this.init, }); } tag 我们从State的源码知道，这个tag定义的是从Get中获取共享变量时的key值。所以如果前后两个页面共享相同实例，当tag有自定义的时候，则前后必须一致。 builder 构建真正的显示Widget. global 定义controller变量是否为全局的。 如果不是全局，则会使用init作为controller，跟随当前Widget的生命周期而回收。 如果是全局，则会查找Get中是否有共享实例。 如果没有，使用init参数作为默认controller，并添加到Get中管理。关于是否回收，需要有autoRemove参数决定。 如果有，则复用共享实例。 autoRemove 如果判断出当前实例是由当前widget所create，则会判断此变量，从而在State.dispose()的时候回收共享实例。 initState、dispose、didChangeDependencies、didUpdateWidget 方法会在State相应方法被调用时，进行回调。 assignId 如果此变量为true，则Get中的实例controller，不论是不是当前create的，都会根据autoRemove尝试回收。 init 默认controller对象。 如果global=false，则直接使用此入参为controller。并在dispose的时候根据autoRemove进行删除 如果global=true，则会尝试从Get中加载指定tag以及类型的共享实例，如果没有，则使用init作为默认参数。同样，在dispose的时候根据 是否为当前create或者是否是assignId，以及 是否autoRemove 进行删除 通过源码阅读我们知道GetX是响应式的自动更新，可以设置controller共享对象，并支持controller的自动回收。但是因为这里的controller对象不是真正的GetXController，所以不支持controller内部的update。 GetX和Obx他们都是响应式自动更新，但是两者最大的区别在于GetX支持很多State生命周期的回调，以及controller的实例共享和生命周期触发。 可以认为Obx是轻量级的GetX实现。 2.3. sum是如何更新的 我们再回过头来看之前提到的官方demo中sum的问题：sum没有使用Rx，但是count1、count2更新时，他同样触发了更新，是如何做到的？ 我们通过分析GetX的代码知道，GetX使用了和Obx相同的proxy互换的技巧提供响应式更新。 其实在build第三个GetX的时候使用了sum，sum就会同步使用count1和count2，当调用他们的get方法时，此时的proxy是当前GetX中的observer，所以count1和count2都会再设置GetX中的observer到流监听中。此时count1被GetX1和GetX3监听，count2被GetX2和GetX3监听，所以当他们任意一个改变时都会触发GetX3的更新。 3. 总结 GetxController通过继承DisposableInterface和mixin ListNotifier的方式，提供了生命周期和批量更新的能力。 而GetX要求入参为DisposableInterface类型，实现了共享实例生命周期的维护。与Obx相同，使用了proxy交换的方式，实现了响应式更新。 我们这里的GetxController中的更新能力在GetX中没有使用(入参是DisposableInterface类型)，但是在后面的GetBuilder中将发挥作用。 Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2021-05-19 11:32:09 "},"flutter/第三方框架/GetX/GetX（三）.html":{"url":"flutter/第三方框架/GetX/GetX（三）.html","title":"GetBuilder","keywords":"","body":"GetX(三) GetBuilder 往期列表： Obx中的魔法 GetX中的GetxController和GetX控件 在上一节中我们一块学习了GetX中的GetxController的源码和作用，以及GetX的详细解读。 在本文中，我们继续学习官方demo中的另一个批量更新控件：GetBuilder，代码如下： class GetBuilder extends StatefulWidget { final GetControllerBuilder builder; final bool global; final Object id; final String tag; final bool autoRemove; final bool assignId; final Object Function(T value) filter; final void Function(State state) initState, dispose, didChangeDependencies; final void Function(GetBuilder oldWidget, State state) didUpdateWidget; final T init; const GetBuilder({ Key key, this.init, this.global = true, @required this.builder, this.autoRemove = true, this.assignId = false, this.initState, this.filter, this.tag, this.dispose, this.id, this.didChangeDependencies, this.didUpdateWidget, }) : assert(builder != null), super(key: key); @override _GetBuilderState createState() => _GetBuilderState(); } 从上述源码可以看出，GetBuilder的定义和GetX的定义十分相近，每个参数所提供的功能也基本相同。他们的不同之处在于： 定义规定的泛型不同 class GetBuilder 我们知道GetX规定的入参泛型为 DisposableInterface 类型，所以GetX的入参只支持生命周期回调，而不支持controller手动更新。我们在分析GetxController的源码时介绍过，他继承自DisposableInterface，并且又通过mixin的方式融入了批量更新的功能。所以我们推测GetBuilder支持controller中手动更新。 filter参数 id参数 下面我们具体看一下State的实现，寻找三处不同的具体差别。 1. _GetBuilderState源码分析 我们直接进入正题，查看一下_GetBuilderState的源码： class _GetBuilderState extends State> with GetStateUpdaterMixin { T controller; bool isCreator = false; VoidCallback remove; Object _filter; @override void initState() { super.initState(); // 初始化controller，与GetX中的一致，省略... // 1 if (widget.filter != null) { _filter = widget.filter(controller); } _subscribeToController(); } // 2 void _subscribeToController() { remove?.call(); remove = (widget.id == null) ? controller?.addListener( _filter != null ? _filterUpdate : getUpdate, ) : controller?.addListenerId( widget.id, _filter != null ? _filterUpdate : getUpdate, ); } // 3 void _filterUpdate() { var newFilter = widget.filter(controller); if (newFilter != _filter) { _filter = newFilter; getUpdate(); } } @override Widget build(BuildContext context) { return widget.builder(controller); } } mixin GetStateUpdaterMixin on State { void getUpdate() { if (mounted) setState(() {}); } } 从源码我们看到，GetBuilder中的区别从上到下依次为： mixin GetStateUpdaterMixin 从GetStateUpdaterMixin中的代码我们知道，其实并没有做太多事情，只是增加了state状态判断以及简化了state的调用。 listener的注册 当init执行完成后，会根据当前widget.id是否为null，在controller中注册更新监听。而监听的回调会根据filter的状态，决定是否更新UI。例如，我们的controller是多个GetBuilder共享，当controller更新时，可使用refreshGroup()的方式批量更新对应id的GetBuilder，使用refresh()的方式更新没有指定id的GetBuilder。 filter 根据注释1我们知道，当init的时候会第一次调用filter。 如果返回值不为空，则后续的更新回调，将使用_filterUpdate()的方式进行。而此方法中，又会回调filter，让外部决定是否更新。如果新返回的值与原始值相同，则不更新，否则更新。 如果返回值为空，则直接使用mixin进来的getUpdate方法进行更新 build方法 从源码可以看到，这里并没有像GetX与Obx中那样使用proxy交换的方式远程注册监听，而是直接调用的widget.builder(controller)。由此代码以及listener代码我们可知，GetBuilder不支持自动更新UI，需要配合controller中的refresh、refreshGroup进行UI更新。 2. 总结 通过上面的源码阅读与分析我们知道，GetBuilder的设计是用来与GetxController进行配合使用。在需要批量更新和区别更新(refreshGroup)时，会比GetX和Obx更加灵活。 GetBuilder与GetX等不同，他不支持自动更新。需要我们在Controller中有数据变化和更新需求时，手动的进行更新。 GetBuilder提供了filter参数，通过此参数，我们可以更加细粒度的控制每次更新触发时，是否真正的执行更新，或者过滤掉更新请求。 Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2021-05-19 11:32:09 "},"flutter/Flutter源码/":{"url":"flutter/Flutter源码/","title":"Flutter源码","keywords":"","body":"Flutter框架源码 本文档主要包括Flutter框架源码阅读分享 Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2021-05-21 18:47:50 "},"flutter/Flutter源码/image.html":{"url":"flutter/Flutter源码/image.html","title":"Image源码分析","keywords":"","body":"Image的基本使用 Image是显示图片的一个Widget。image支持的图片格式为：JPEG, PNG, GIF, Animated GIF, WebP, Animated WebP, BMP, and WBMP。 image的基本使用方法: 构造方法 描述 Image() 从ImageProvider中获取图片，从本质上看，下面的几个方法都是他的具体实现。 Image.asset(String name) 从AssetBundler中获取图片 Image.network(String url) 显示网络图片，参数为url Image.file(File file) 从File中获取图片 Image.memory(Uint8List bytes) 从Uint8List中显示图片 具体使用： image.asset加载资源图片 Flutter可以为当前设备加载适合其分辨率的图像。 首先要在根目录assets下,新建image文件夹，由于Flutter加载图片时需要2倍图、3倍图，默认图。所以需要同时新建2.0x和3.0x文件夹。 然后，在pubspec.yaml配置文件中，yaml是类似于xml的一种标记性语言，其中“-”表示数组。在这里，我们也可以使用下面的写法，加载整个资源文件图片： 使用资源图片文件(填入图片的全路径即可)： Image.asset(\"assets/images/flutter.jpeg\") Image.network加载网络图片 Image.network( 'https://image1.guazistatic.com/qn210519171455ac369db6cfecbf11d017210f2986a031.jpg') Image.file加载图片文件 Image.file(File(\"/sdcard/flutter.jpeg\")) 注意在AndroidManifest.xml中配置读写文件权限 Image.memory加载缓存文件 Image.memory(bytes); fit属性的设置 fit属性可以控制图片的拉伸和挤压，这些都是根据图片的父级容器来的. BoxFit.fill:全图显示，图片会被拉伸，并充满父容器。 BoxFit.contain:全图显示，显示原比例，可能会有空隙。 BoxFit.cover：显示可能拉伸，可能裁切，充满（图片要充满整个容器，还不变形）。 BoxFit.fitWidth：宽度充满（横向充满），显示可能拉伸，可能裁切。 BoxFit.fitHeight ：高度充满（竖向充满）,显示可能拉伸，可能裁切。 BoxFit.scaleDown：效果和contain差不多，但是此属性不允许显示超过源图片大小，可小不可大。 repeat图片重复 ImageRepeat.repeat : 横向和纵向都进行重复，直到铺满整个画布。 ImageRepeat.repeatX: 横向重复，纵向不重复。 ImageRepeat.repeatY：纵向重复，横向不重复。 ImageRepeat.noRepeat:不重复。 alignment图片对齐 Alignment.center:居中 Alignment.centerLeft:居左 Alignment.centerRight:居右 Alignment.topCenter:顶部居中 Alignment.topLeft:顶部居左 Alignment.topRight:顶部居右 Alignment.bottomCenter:底部居中 Alignment.bottomLeft:底部居左 Alignment.bottomRight:底部居右 colorBlendMode图片颜色及混合模式 color为源图像，image为目标图像 BlendMode.clear:不显示源图像和目标图像。 BlendMode.src:仅显示源图像。 BlendMode.dst:仅绘制目标图像。 BlendMode.srcOver:源图显示到目标图像上，源图像在上面,透明区域显示目标图层。 BlendMode.dstOver:目标图像显示在源图像上，目标图像在上面。 BlendMode.srcIn: 显示源图像且仅显示两个图像重叠位置。目标图像不绘制，只有不透明度起作用。 BlendMode.dstIn:显示目标图像且仅显示两个图像重叠部分，源图像不绘制只有不透明度起作用。 BlendMode.srcOut:显示源图像且仅显示两个图像不重叠位置。目标图像不绘制，只有不透明度起作用。 BlendMode.dstOut:显示目标图像且仅显示两个图像不重叠部分，源图像不绘制只有不透明度起作用。 BlendMode.srcATop:将源图像合成到目标图像上，但仅在与目标图像重叠的位置合成。但是输出的不透明度通道设置为目标图像的不透明度通道，而不是两个图像的不透明度通道的组合。 BlendMode.dstATop:将目标图像合成到源图像上，但仅在与源图像重叠的位置合成。但是将输出的不透明度通道设置为源图像的不透明度通道，而不是将两个图像的不透明度通道组合在一起。 BlendMode.xor:对源图像和目标图像应用按位“ xor”运算符。这将使它们重叠的地方保持透明。 BlendMode.plus:对源图像和目标图像的组成部分求和。 BlendMode.modulate:将源图像和目标图像的颜色分量相乘。这只能产生相同或较深的颜色（乘以白色1.0，结果不变；乘以黑色0.0，结果黑色）。合成两个不透明图像时，这与在投影机上重叠两个透明胶片具有相似的效果。 BlendMode.screen:将源图像和目标图像的分量的逆值相乘，然后将结果相逆。反转分量意味着将完全饱和的通道（不透明的白色）视为值0.0，将通常视为0.0的值（黑色，透明）视为1.0。这本质上与[调制]混合模式相同，但是颜色的值在乘法之前先反转，结果在渲染前先反转。这只能导致颜色相同或更浅（乘以黑色1.0不会导致更改；乘以白色0.0则会导致白色）。同样，在Alpha通道中，它只能导致更不透明的颜色。这与两台投影机在同一屏幕上同时显示其图像的效果相似。 BlendMode.overlay:在将源图像和目标图像的分量调整为适合目标后，将它们相乘。具体而言，如果目标值较小，则将其与源值相乘，而当源值较小时，则将源值的逆与目标值的逆相乘，然后求反。反转分量意味着将完全饱和的通道（不透明的白色）视为值0.0，将通常视为0.0的值（黑色，透明）视为1.0。 BlendMode.darken:通过从每个颜色通道中选择最小值来合成源图像和目标图像,透明区域显示目标图层。 BlendMode.lighten:通过从每个颜色通道中选择最大值来合成源图像和目标图像,透明区域显示目标图层。 BlendMode.colorDodge:将目标除以源的倒数。反转分量意味着将完全饱和的通道（不透明的白色）视为值0.0，将通常视为0.0的值（黑色，透明）视为1.0。 BlendMode.colorBurn:将目标的倒数除以源，然后将结果倒数。反转分量意味着将完全饱和的通道（不透明的白色）视为值0.0，将通常视为0.0的值（黑色，透明）视为1.0。 BlednMode.hardLight:调整源图像和目标图像的分量以使其适合源图像后，将它们相乘。具体来说，如果源值较小，则将其与目标值相乘，而当目标值较小时，则将目标值的逆与源值的逆相乘，然后求反。反转分量意味着将完全饱和的通道（不透明的白色）视为值0.0，将通常视为0.0的值（黑色，透明）视为1.0 BlendMode.softLight: 对于低于0.5的源值使用[colorDodge]，对于高于0.5的源值使用[colorBurn]。与[overlay]相比，这会产生相似但较柔和的效果 BlendMode.difference: 从每个通道的较大值中减去较小的值。合成黑色没有效果。合成白色会使另一张图像的颜色反转。输出图像的不透明度的计算方法与[srcOver]相同。 BlendMode.exclusion: 从两个图像的总和中减去两个图像的乘积的两倍。合成黑色没有效果。合成白色会使另一张图像的颜色反转。输出图像的不透明度的计算方法与[srcOver]相同。效果类似于[difference]，但较柔和。 BlendMode.multiply: 将源图像和目标图像的分量相乘，包括alpha通道。这只能产生相同或较深的颜色（乘以白色1.0，结果不变；乘以黑色0.0，结果黑色）。由于alpha通道也被相乘，因此一幅图像中的全透明像素（不透明度0.0）导致输出中的全透明像素。这类似于[dstIn]，但将颜色组合在一起。对于多种颜色但不乘以Alpha通道的变体，请考虑[modulate]。 BlendMode.hue: 获取源图像的​​色相，以及目标图像的饱和度和光度。效果是用源图像对目标图像进行着色。输出图像的不透明度的计算方法与[srcOver]相同。源图像中完全透明的区域会从目标获得其相色。 BlendMode.saturation: 获取源图像的​​饱和度以及目标图像的色相和亮度。输出图像的不透明度的计算方法与[srcOver]相同。源图像中完全透明的区域从目标位置开始饱和。 BlendMode.color: 获取源图像的​​色相和饱和度以及目标图像的光度。效果是用源图像对目标图像进行着色。输出图像的不透明度的计算方法与[srcOver]相同。源图像中完全透明的区域从目标位置获得其色相和饱和度。 BlendMode.luminosity: 获取源图像的​​亮度，以及目标图像的色相和饱和度。输出图像的不透明度的计算方法与[srcOver]相同。源图像中完全透明的区域从目的地获取其亮度。 centerSlice图片局部放大： 原图： 效果图： Image的源码 下面通过Image.network的源码来看下图片是如何下载以及如何缓存的 首先通过点击红色框可以看到网络加载的图片和AssetImage等都是image_provide的实现类， 它的主要职责有两个： 提供图片数据源 缓存图片 主要基类： resolve方法 使用给定的“ configuration”解析此图像，并返回[ImageStream]。这是[ImageProvider]类层次结构的公共入口点。子类应实现此方法使用的[obtainKey]和[load]。如果他们需要更改使用的[ImageStream]的实现，则应重写[createStream]。如果他们需要管理图像的实际分辨率，则应重写[resolveStreamForKey]。 ImageConfiguration 包含图片和设备的相关信息，如图片的大小、所在的AssetBundle(只有打到安装包的图片存在)以及当前的设备平台、devicePixelRatio（设备像素比等）。Flutter SDK提供了一个便捷函数createLocalImageConfiguration来创建ImageConfiguration 对象： 具体看下resolve方法 有缓存则使用缓存，没有缓存则调用load方法加载图片，加载成功后: 先判断图片数据有没有缓存，如果有，则直接返回ImageStream。 如果没有缓存，则调用load(T key)方法从数据源加载图片数据，加载成功后先缓存，然后返回ImageStream。 这里的PaintingBinding.instance.imageCache 是 ImageCache的一个实例，它是PaintingBinding的一个属性，而Flutter框架中的PaintingBinding.instance是一个单例，imageCache事实上也是一个单例，也就是说图片缓存是全局的，统一由PaintingBinding.instance.imageCache 来管理。 这里是不是很熟悉。 来看一下ImageCache 可以看到： _pendingImages正在加载中的图片队列 _cache缓存队列 缓存图片上线1000张，最大缓存100M 可以看到，这里检测缓存图片是否存在，存在则直接返回，不存在则删掉缓存中对应的key，然后缓存图片。 当缓存数量超过最大值或缓存大小超过最大缓存容量，则会清理到缓存上限以内。 obtainKey方法 该接口主要是为了配合实现图片缓存，ImageProvider从数据源加载完数据后，会在全局的ImageCache中缓存图片数据，而图片数据缓存是一个Map，而Map的key便是调用此方法的返回值，不同的key代表不同的图片数据缓存。对应实现： 因为Map中在判断key（此时是NetworkImage对象）是否相等时会使用\"=\"运算符，那么定义key的逻辑就是NetworkImage的“==”运算符： 这里可以看出key是由url+scale决定的，同一个url不同scale会重复下载。 load方法 将密钥转换为[ImageStreamCompleter]，然后开始获取图像。 [decode]回调提供了获取图像编解码器的逻辑。 load方法的返回值类型是ImageStreamCompleter ，它是一个抽象类，定义了管理图片加载过程的一些接口，Image Widget中正是通过它来监听图片加载状态的。 MultiFrameImageStreamCompleter 是 ImageStreamCompleter的一个子类，是flutter sdk预置的类，通过该类，我们可以方便、轻松地创建出一个ImageStreamCompleter实例来做为load方法的返回值。 具体子类NetworkImage实现load 可以看到_loadAsync方法主要做了两件事： 1.下载图片。 2.对下载的图片数据进行解码。 这里获取图片，解码图片。具体解码图片是底层做的。 我们可以看到Codec最终的结果是一个或多个（动图）帧，而这些帧最终会绘制到屏幕上。 另外，我们需要注意的是，图片缓存是在内存中，并没有进行本地文件持久化存储，这也是为什么网络图片在应用重启后需要重新联网下载的原因。 Image第三方控件 flutter_svg控件 对于flutter_svg这个控件，因为我们看过flutter原生的image的解析和缓存过程了，在看这个控件就很简单了。首先我们看下这个控件对外提供的几个基本的使用方法。 可以看到，对外提供了这三种加载svg的方法。 下面我们也从SvgPicture.network来了解flutter_svg的源码。 SvgPicture.network加载网络svg图片 首先看到这个方法存在于SvgPicture这个类里。 然后SvgPicture 他是一个StatefulWidget，然后这个类他必然后build和createState方法，这样我们直接去看他的build方法 可以看到build是绘制的_picture然后画出来的svg图片，这里_picture是一个包含Picture的用来绘制到canvas上的实体类。 Picture则是表示记录的图形操作序列的对象，可以使用[SceneBuilder]将[Picture]放置在[Scene]中。也可以使用[Canvas.drawPicture]方法将[Picture]绘制到[Canvas]中。 URL中的byte加载到PictureInfo流程 首先看到NetworkPicture是从PictureProvider实现过来的。 PictureProvider有三个和ImageProvider一样的方法，其实起到的作用也一样，咱们这里就不详细说了。 resole：是公共入口，里面调用了obtainKey和load方法，然后子类要实现obtainKey和load方法。 obtainKey：通过PictureConfiguration获取图片的key作为唯一标识。 load：通过key加载图片返回PictureStreamCompleter，这样一个管理图片的对象。 缓存 这里同样是有缓存则直接用缓存文件，没有则调用load方法从网络下载。和原生ImageProvider不同的是svg缓存只有一个限制最大1000个svg图片。 可以看到这里缓存svg图片，先判断是否有缓存，如果有直接用，如果没有判断是否超过最大缓存数量限制，如果超过移除第一个然后，从网络加载，先存到缓存然后返回。 查看load实现。 同样的NetworkPicture中有通过url下载图片，最后_loadAsync返回PictureInfo，以及图片的key是由url+colorFilter组成，这样的代码。 那么bytes是怎么解析成PictureInfo的呢？ 看到这里就很清楚了 然后看到这里是通过SvgParser解析得到的。到这里整个的svg图片加载实际就理顺了。 Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2021-05-21 18:47:50 "},"GLOSSARY.html":{"url":"GLOSSARY.html","keywords":"","body":"MoonTools 皓月开发工具,参考 MoonTools moon-tools 皓月开发工具,参考 MoonTools Project 在AS中作为整个工作环境存在，可以包含多个Module。 Module 在AS中作为真正的开发的内容存在，是一个个独立功能的单元模块，可以被其他Module依赖。 kit-upgrade kit库更新日志，参见kit更新文档 KitImport kit库更新日志，参见kit引入文档 Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2021-05-18 15:24:35 "}}